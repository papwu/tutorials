<!DOCTYPE html>
<html lang="en-US">
<head>
<title>Time Series - Quick Guide - Tutorialspoint</title>
<meta charset="utf-8">
<meta name="description" content="Time Series - Quick Guide - A time series is a sequence of observations over a certain period. A univariate time series consists of the values taken by a single variable at periodic time i"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/time_series/time_series_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#036db0;
}
a.demo {
    background:#036db0;
}
li.heading {
    background:#036db0;
}
.course-box{background:#036db0}
.home-intro-sub p{color:#036db0}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/time_series/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
"HTML-CSS": {
linebreaks: { automatic: true, width: "container" }          
}              
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<div class="mini-logo">
<img src="/time_series/images/time-series-mini-logo.jpg" alt="Time Series Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">Time Series Tutorial</li>
<li><a href="/time_series/index.htm">Time Series - Home</a></li>
<li><a href="/time_series/time_series_introduction.htm">Time Series - Introduction</a></li>
<li><a href="/time_series/time_series_programming_languages.htm">Time Series - Programming Languages</a></li>
<li><a href="/time_series/time_series_python_libraries.htm">Time Series - Python Libraries</a></li>
<li><a href="/time_series/time_series_data_processing_and_visualization.htm">Data Processing &amp; Visualization</a></li>
<li><a href="/time_series/time_series_modeling.htm">Time Series - Modeling</a></li>
<li><a href="/time_series/time_series_parameter_calibration.htm">Time Series - Parameter Calibration</a></li>
<li><a href="/time_series/time_series_naive_methods.htm">Time Series - Naive Methods</a></li>
<li><a href="/time_series/time_series_server_auto_regression.htm">Time Series - Auto Regression</a></li>
<li><a href="/time_series/time_series_moving_average.htm">Time Series - Moving Average</a></li>
<li><a href="/time_series/time_series_arima.htm">Time Series - ARIMA</a></li>
<li><a href="/time_series/time_series_variations_of_arima.htm">Time Series - Variations of ARIMA</a></li>
<li><a href="/time_series/time_series_exponential_smoothing.htm">Time Series - Exponential Smoothing</a></li>
<li><a href="/time_series/time_series_walk_forward_validation.htm">Time Series - Walk Forward Validation</a></li>
<li><a href="/time_series/time_series_prophet_model.htm">Time Series - Prophet Model</a></li>
<li><a href="/time_series/time_series_lstm_model.htm">Time Series - LSTM Model</a></li>
<li><a href="/time_series/time_series_error_metrics.htm">Time Series - Error Metrics</a></li>
<li><a href="/time_series/time_series_applications.htm">Time Series - Applications</a></li>
<li><a href="/time_series/time_series_further_scope.htm">Time Series - Further Scope</a></li>
<li class="heading">Time Series Useful Resources</li>
<li><a href="/time_series/time_series_quick_guide.htm">Time Series - Quick Guide</a></li>
<li><a href="/time_series/time_series_useful_resources.htm">Time Series - Useful Resources</a></li>
<li><a href="/time_series/time_series_discussion.htm">Time Series - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>Time Series - Quick Guide</h1>
<hr/>
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/time_series/time_series_further_scope.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/time_series/time_series_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>Time Series - Introduction</h1>
<p>A time series is a sequence of observations over a certain period. A univariate time series consists of the values taken by a single variable at periodic time instances over a period, and a multivariate time series consists of the values taken by multiple variables at the same periodic time instances over a period. The simplest example of a time series that all of us come across on a day to day basis is the change in temperature throughout the day or week or month or year.</p>
<p>The analysis of temporal data is capable of giving us useful insights on how a variable changes over time, or how it depends on the change in the values of other variable(s). This relationship of a variable on its previous values and/or other variables can be analyzed for time series forecasting and has numerous applications in artificial intelligence.</p>
<h1>Time Series - Programming Languages</h1>
<p>A basic understanding of any programming language is essential for a user to work with or develop machine learning problems. A list of preferred programming languages for anyone who wants to work on machine learning is given below &minus;</p>
<h2>Python</h2>
<p>It is a high-level interpreted programming language, fast and easy to code. Python can follow either procedural or object-oriented programming paradigms. The presence of a variety of libraries makes implementation of complicated procedures simpler. In this tutorial, we will be coding in Python and the corresponding libraries useful for time series modelling will be discussed in the upcoming chapters.</p>
<h2>R</h2>
<p>Similar to Python, R is an interpreted multi-paradigm language, which supports statistical computing and graphics. The variety of packages makes it easier to implement machine learning modelling in R.</p>
<h2>Java</h2>
<p>It is an interpreted object-oriented programming language, which is widely famous for a large range of package availability and sophisticated data visualization techniques.</p>
<h2>C/C++</h2>
<p>These are compiled languages, and two of the oldest programming languages. These languages are often preferred to incorporate ML capabilities in the already existing applications as they allow you to customize the implementation of ML algorithms easily.</p>
<h2>MATLAB</h2>
<p>MATrix LABoratory is a multi-paradigm language which gives functioning to work with matrices. It allows mathematical operations for complex problems. It is primarily used for numerical operations but some packages also allow the graphical multi-domain simulation and model-based design.</p>
<p>Other preferred programming languages for machine learning problems include JavaScript, LISP, Prolog, SQL, Scala, Julia, SAS etc.</p>
<h1>Time Series - Python Libraries</h1>
<p>Python has an established popularity among individuals who perform machine learning because of its easy-to-write and easy-to-understand code structure as well as a wide variety of open source libraries. A few of such open source libraries that we will be using in the coming chapters have been introduced below.</p>
<h2>NumPy</h2>
<p>Numerical Python is a library used for scientific computing. It works on an N-dimensional array object and provides basic mathematical functionality such as size, shape, mean, standard deviation, minimum, maximum as well as some more complex functions such as linear algebraic functions and Fourier transform. You will learn more about these as we move ahead in this tutorial.</p>
<h2>Pandas</h2>
<p>This library provides highly efficient and easy-to-use data structures such as series, dataframes and panels. It has enhanced Python’s functionality from mere data collection and preparation to data analysis. The two libraries, Pandas and NumPy, make any operation on small to very large dataset very simple. To know more about these functions, follow this tutorial.</p>
<h2>SciPy</h2>
<p>Science Python is a library used for scientific and technical computing. It provides functionalities for optimization, signal and image processing, integration, interpolation and linear algebra. This library comes handy while performing machine learning. We will discuss these functionalities as we move ahead in this tutorial.</p>
<h2>Scikit Learn</h2>
<p>This library is a SciPy Toolkit widely used for statistical modelling, machine learning and deep learning, as it contains various customizable regression, classification and clustering models. It works well with Numpy, Pandas and other libraries which makes it easier to use.</p>
<h2>Statsmodels</h2>
<p>Like Scikit Learn, this library is used for statistical data exploration and statistical modelling. It also operates well with other Python libraries.</p>
<h2>Matplotlib</h2>
<p>This library is used for data visualization in various formats such as line plot, bar graph, heat maps, scatter plots, histogram etc. It contains all the graph related functionalities required from plotting to labelling. We will discuss these functionalities as we move ahead in this tutorial.</p>
<p>These libraries are very essential to start with machine learning with any sort of data.</p>
<p>Beside the ones discussed above, another library especially significant to deal with time series is &minus;</p>
<h2>Datetime</h2>
<p>This library, with its two modules &minus; datetime and calendar, provides all necessary datetime functionality for reading, formatting and manipulating time.</p>
<p>We shall be using these libraries in the coming chapters.</p>
<h1>Time Series - Data Processing and Visualization</h1>
<p>Time Series is a sequence of observations indexed in equi-spaced time intervals. Hence, the order and continuity should be maintained in any time series.</p>
<p>The dataset we will be using is a multi-variate time series having hourly data for approximately one year, for air quality in a significantly polluted Italian city. The dataset can be downloaded from the link given below &minus; <a target="_blank" rel="nofollow" href="https://archive.ics.uci.edu/ml/datasets/air+quality">https://archive.ics.uci.edu/ml/datasets/air+quality</a>.</p>
<p>It is necessary to make sure that &minus;</p>
<ul class="list">
<li><p>The time series is equally spaced, and</p></li>
<li><p>There are no redundant values or gaps in it.</p></li>
</ul>
<p>In case the time series is not continuous, we can upsample or downsample it.</p>
<h2>Showing df.head()</h2>
<p>In [122]:</p>
<pre class="result notranslate">
import pandas
</pre>
<p>In [123]:</p>
<pre class="result notranslate">
df = pandas.read_csv("AirQualityUCI.csv", sep = ";", decimal = ",")
df = df.iloc[ : , 0:14]
</pre>
<p>In [124]:</p>
<pre class="result notranslate">
len(df)
</pre>
<p>Out[124]:</p>
<pre class="result notranslate">
9471
</pre>
<p>In [125]:</p>
<pre class="result notranslate">
df.head()
</pre>
<p>Out[125]:</p>
<img class="full-width" src="/time_series/images/code_snippet.jpg" alt="Code Snippet" />
<p>For preprocessing the time series, we make sure there are no NaN(NULL) values in the dataset; if there are, we can replace them with either 0 or average or preceding or succeeding values. Replacing is a preferred choice over dropping so that the continuity of the time series is maintained. However, in our dataset the last few values seem to be NULL and hence dropping will not affect the continuity.</p>
<h2>Dropping NaN(Not-a-Number)</h2>
<p>In [126]:</p>
<pre class="result notranslate">
df.isna().sum()
Out[126]:
Date             114
Time             114
CO(GT)           114
PT08.S1(CO)      114
NMHC(GT)         114
C6H6(GT)         114
PT08.S2(NMHC)    114
NOx(GT)          114
PT08.S3(NOx)     114
NO2(GT)          114
PT08.S4(NO2)     114
PT08.S5(O3)      114
T                114
RH               114
dtype: int64
</pre>
<p>In [127]:</p>
<pre class="result notranslate">
df = df[df['Date'].notnull()]
</pre>
<p>In [128]:</p>
<pre class="result notranslate">
df.isna().sum()
</pre>
<p>Out[128]:</p>
<pre class="result notranslate">
Date             0
Time             0
CO(GT)           0
PT08.S1(CO)      0
NMHC(GT)         0
C6H6(GT)         0
PT08.S2(NMHC)    0
NOx(GT)          0
PT08.S3(NOx)     0
NO2(GT)          0
PT08.S4(NO2)     0
PT08.S5(O3)      0
T                0
RH               0
dtype: int64
</pre>
<p>Time Series are usually plotted as line graphs against time. For that we will now combine the date and time column and convert it into a datetime object from strings. This can be accomplished using the datetime library.</p>
<h2>Converting to datetime object</h2>
<p>In [129]:</p>
<pre class="result notranslate">
df['DateTime'] = (df.Date) + ' ' + (df.Time)
print (type(df.DateTime[0]))
</pre>
<p><b>&lt;class 'str'&gt;</b></p>
<p>In [130]:</p>
<pre class="result notranslate">
import datetime

df.DateTime = df.DateTime.apply(lambda x: datetime.datetime.strptime(x, '%d/%m/%Y %H.%M.%S'))
print (type(df.DateTime[0]))
</pre>
<p>&lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;</p>
<p>Let us see how some variables like temperature changes with change in time.</p>
<h2>Showing plots</h2>
<p>In [131]:</p>
<pre class="result notranslate">
df.index = df.DateTime
</pre>
<p>In [132]:</p>
<pre class="result notranslate">
import matplotlib.pyplot as plt
plt.plot(df['T'])
</pre>
<p>Out[132]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eaad67f780&gt;]
</pre>
<img class="center" src="/time_series/images/code_snippet4.jpg" alt="Code Snippet 4" />
<p>In [208]:</p>
<pre class="result notranslate">
plt.plot(df['C6H6(GT)'])
</pre>
<p>Out[208]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eaaeedff28&gt;]
</pre>
<p>Box-plots are another useful kind of graphs that allow you to condense a lot of information about a dataset into a single graph. It shows the mean, 25% and 75% quartile and outliers of one or multiple variables. In the case when number of outliers is few and is very distant from the mean, we can eliminate the outliers by setting them to mean value or 75% quartile value.</p>
<h2>Showing Boxplots</h2>
<p>In [134]:</p>
<pre class="result notranslate">
plt.boxplot(df[['T','C6H6(GT)']].values)
</pre>
<p>Out[134]:</p>
<pre class="result notranslate">
{'whiskers': [&lt;matplotlib.lines.Line2D at 0x1eaac16de80&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac16d908&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac177a58&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac177cf8&gt;],
   'caps': [&lt;matplotlib.lines.Line2D at 0x1eaac16d2b0&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac16d588&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac1a69e8&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac1a64a8&gt;],
   'boxes': [&lt;matplotlib.lines.Line2D at 0x1eaac16dc50&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac1779b0&gt;],
   'medians': [&lt;matplotlib.lines.Line2D at 0x1eaac16d4a8&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac1a6c50&gt;],
   'fliers': [&lt;matplotlib.lines.Line2D at 0x1eaac177dd8&gt;,
   &lt;matplotlib.lines.Line2D at 0x1eaac1a6c18&gt;],'means': []
}
</pre>
<img class="center" src="/time_series/images/code_snippet5.jpg" alt="Code Snippet 5" />
<h1>Time Series - Modeling</h1>
<h2>Introduction</h2>
<p>A time series has 4 components as given below &minus;</p>
<ul class="list">
<li><p><b>Level</b> &minus; It is the mean value around which the series varies.</p></li>
<li><p><b>Trend</b> &minus; It is the increasing or decreasing behavior of a variable with time.</p></li>
<li><p><b>Seasonality</b> &minus; It is the cyclic behavior of time series.</p></li>
<li><p><b>Noise</b> &minus; It is the error in the observations added due to environmental factors.</p></li>
</ul>
<h2>Time Series Modeling Techniques</h2>
<p>To capture these components, there are a number of popular time series modelling techniques. This section gives a brief introduction of each technique, however we will discuss about them in detail in the upcoming chapters &minus;</p>
<h3>Naïve Methods</h3>
<p>These are simple estimation techniques, such as the predicted value is given the value equal to mean of preceding values of the time dependent variable, or previous actual value. These are used for comparison with sophisticated modelling techniques.</p>
<h3>Auto Regression</h3>
<p>Auto regression predicts the values of future time periods as a function of values at previous time periods. Predictions of auto regression may fit the data better than that of naïve methods, but it may not be able to account for seasonality.</p>
<h3>ARIMA Model</h3>
<p>An auto-regressive integrated moving-average models the value of a variable as a linear function of previous values and residual errors at previous time steps of a stationary timeseries. However, the real world data may be non-stationary and have seasonality, thus Seasonal-ARIMA and Fractional-ARIMA were developed. ARIMA works on univariate time series, to handle multiple variables VARIMA was introduced.</p>
<h3>Exponential Smoothing</h3>
<p>It models the value of a variable as an exponential weighted linear function of previous values. This statistical model can handle trend and seasonality as well.</p>
<h3>LSTM</h3>
<p>Long Short-Term Memory model (LSTM) is a recurrent neural network which is used for time series to account for long term dependencies. It can be trained with large amount of data to capture the trends in multi-variate time series.</p>
<p>The said modelling techniques are used for time series regression. In the coming chapters, let us now explore all these one by one.</p>
<h1>Time Series - Parameter Calibration</h1>
<h2>Introduction</h2>
<p>Any statistical or machine learning model has some parameters which greatly influence how the data is modeled. For example, ARIMA has p, d, q values. These parameters are to be decided such that the error between actual values and modeled values is minimum. Parameter calibration is said to be the most crucial and time-consuming task of model fitting. Hence, it is very essential for us to choose optimal parameters.</p>
<h2>Methods for Calibration of Parameters</h2>
<p>There are various ways to calibrate parameters. This section talks about some of them in detail.</p>
<h3>Hit-and-try</h3>
<p>One common way of calibrating models is hand calibration, where you start by visualizing the time-series and intuitively try some parameter values and change them over and over until you achieve a good enough fit. It requires a good understanding of the model we are trying. For ARIMA model, hand calibration is done with the help of auto-correlation plot for ‘p’ parameter, partial auto-correlation plot for ‘q’ parameter and ADF-test to confirm the stationarity of time-series and setting ‘d’ parameter. We will discuss all these in detail in the coming chapters.</p>
<h3>Grid Search</h3>
<p>Another way of calibrating models is by grid search, which essentially means you try building a model for all possible combinations of parameters and select the one with minimum error. This is time-consuming and hence is useful when number of parameters to be calibrated and range of values they take are fewer as this involves multiple nested for loops.</p>
<h3>Genetic Algorithm</h3>
<p>Genetic algorithm works on the biological principle that a good solution will eventually evolve to the most ‘optimal’ solution. It uses biological operations of mutation, cross-over and selection to finally reach to an optimal solution.</p>
<p>For further knowledge you can read about other parameter optimization techniques like Bayesian optimization and Swarm optimization.</p>
<h1>Time Series - Naïve Methods</h1>
<h2>Introduction</h2>
<p>Naïve Methods such as assuming the predicted value at time ‘t’ to be the actual value of the variable at time ‘t-1’ or rolling mean of series, are used to weigh how well do the statistical models and machine learning models can perform and emphasize their need.</p>
<p>In this chapter, let us try these models on one of the features of our time-series data.</p>
<p>First we shall see the mean of the ‘temperature’ feature of our data and the deviation around it. It is also useful to see maximum and minimum temperature values. We can use the functionalities of numpy library here.</p>
<h2>Showing statistics</h2>
<p>In [135]:</p>
<pre class="prettyprint notranslate">
import numpy
print (
   'Mean: ',numpy.mean(df['T']), '; 
   Standard Deviation: ',numpy.std(df['T']),'; 
   \nMaximum Temperature: ',max(df['T']),'; 
   Minimum Temperature: ',min(df['T'])
)
</pre>
<p>We have the statistics for all 9357 observations across equi-spaced timeline which are useful for us to understand the data.</p>
<p>Now we will try the first naïve method, setting the predicted value at present time equal to actual value at previous time and calculate the root mean squared error(RMSE) for it to quantify the performance of this method.</p>
<h2>Showing 1<sup>st</sup> naïve method</h2>
<p>In [136]:</p>
<pre class="result notranslate">
df['T']
df['T_t-1'] = df['T'].shift(1)
</pre>
<p>In [137]:</p>
<pre class="result notranslate">
df_naive = df[['T','T_t-1']][1:]
</pre>
<p>In [138]:</p>
<pre class="result notranslate">
from sklearn import metrics
from math import sqrt

true = df_naive['T']
prediction = df_naive['T_t-1']
error = sqrt(metrics.mean_squared_error(true,prediction))
print ('RMSE for Naive Method 1: ', error)
</pre>
<p>RMSE for Naive Method 1: 12.901140576492974</p>
<p>Let us see the next naïve method, where predicted value at present time is equated to the mean of the time periods preceding it. We will calculate the RMSE for this method too.</p>
<h2>Showing 2<sup>nd</sup> naïve method</h2>
<p>In [139]:</p>
<pre class="result notranslate">
df['T_rm'] = df['T'].rolling(3).mean().shift(1)
df_naive = df[['T','T_rm']].dropna()
</pre>
<p>In [140]:</p>
<pre class="result notranslate">
true = df_naive['T']
prediction = df_naive['T_rm']
error = sqrt(metrics.mean_squared_error(true,prediction))
print ('RMSE for Naive Method 2: ', error)
</pre>
<p><b>RMSE for Naive Method 2: 14.957633272839242</b></p>
<p>Here, you can experiment with various number of previous time periods also called ‘lags’ you want to consider, which is kept as 3 here. In this data it can be seen that as you increase the number of lags and error increases. If lag is kept 1, it becomes same as the naïve method used earlier.</p>
<p><b>Points to Note</b></p>
<ul class="list">
<li><p>You can write a very simple function for calculating root mean squared error. Here, we have used the mean squared error function from the package ‘sklearn’ and then taken its square root.</p></li>
<li><p>In pandas df[‘column_name’] can also be written as df.column_name, however for this dataset df.T will not work the same as df[‘T’] because df.T is the function for transposing a dataframe. So use only df[‘T’] or consider renaming this column before using the other syntax.</p></li>
</ul>
<h1>Time Series - Auto Regression</h1>
<p>For a stationary time series, an auto regression models sees the value of a variable at time ‘t’ as a linear function of values ‘p’ time steps preceding it. Mathematically it can be written as &minus;</p>
<p>$$y_{t} = \:C+\:\phi_{1}y_{t-1}\:+\:\phi_{2}Y_{t-2}+...+\phi_{p}y_{t-p}+\epsilon_{t}$$</p>
<p>&nbsp;</p>
<p>Where,<span style="margin-left:14%;">‘p’ is the auto-regressive trend parameter</span></p>
<p style="margin-left:22%;">$\epsilon_{t}$ is white noise, and</p>
<p style="margin-left:22%;">$y_{t-1}, y_{t-2}\:\: ...y_{t-p}$ denote the value of variable at previous time periods.</p>
<p>The value of p can be calibrated using various methods. One way of finding the apt value of ‘p’ is plotting the auto-correlation plot.</p>
<p><b>Note</b> &minus; We should separate the data into train and test at 8:2 ratio of total data available prior to doing any analysis on the data because test data is only to find out the accuracy of our model and assumption is, it is not available to us until after predictions have been made. In case of time series, sequence of data points is very essential so one should keep in mind not to lose the order during splitting of data.</p>
<p>An auto-correlation plot or a correlogram shows the relation of a variable with itself at prior time steps. It makes use of Pearson’s correlation and shows the correlations within 95% confidence interval. Let’s see how it looks like for ‘temperature’ variable of our data.</p>
<h2>Showing ACP</h2>
<p>In [141]:</p>
<pre class="result notranslate">
split = len(df) - int(0.2*len(df))
train, test = df['T'][0:split], df['T'][split:]
</pre>
<p>In [142]:</p>
<pre class="result notranslate">
from statsmodels.graphics.tsaplots import plot_acf

plot_acf(train, lags = 100)
plt.show()
</pre>
<img class="center" src="/time_series/images/code_snippet9.jpg" alt="Code Snippet 9" />
<p>All the lag values lying outside the shaded blue region are assumed to have a csorrelation.</p>
<h1>Time Series - Moving Average</h1>
<p>For a stationary time series, a moving average model sees the value of a variable at time ‘t’ as a linear function of residual errors from ‘q’ time steps preceding it. The residual error is calculated by comparing the value at the time ‘t’ to moving average of the values preceding.</p>
<p>Mathematically it can be written as &minus;</p>
<p>$$y_{t} = c\:+\:\epsilon_{t}\:+\:\theta_{1}\:\epsilon_{t-1}\:+\:\theta_{2}\:\epsilon_{t-2}\:+\:...+:\theta_{q}\:\epsilon_{t-q}\:$$</p>
<p>Where<span style="margin-left:12%">‘q’ is the moving-average trend parameter</span></p>
<p style="margin-left:20%">$\epsilon_{t}$ is white noise, and</p>
<p style="margin-left:20%">$\epsilon_{t-1}, \epsilon_{t-2}...\epsilon_{t-q}$ are the error terms at previous time periods.</p>
<p>Value of ‘q’ can be calibrated using various methods. One way of finding the apt value of ‘q’ is plotting the partial auto-correlation plot.</p>
<p>A partial auto-correlation plot shows the relation of a variable with itself at prior time steps with indirect correlations removed, unlike auto-correlation plot which shows direct as well as indirect correlations, let’s see how it looks like for ‘temperature’ variable of our data.</p>
<h2>Showing PACP</h2>
<p>In [143]:</p>
<pre class="result notranslate">
from statsmodels.graphics.tsaplots import plot_pacf

plot_pacf(train, lags = 100)
plt.show()
</pre>
<img class="center" src="/time_series/images/code_snippet10.jpg" alt="Code Snippet 10" />
<p>A partial auto-correlation is read in the same way as a correlogram.</p>
<h1>Time Series - ARIMA</h1>
<p>We have already understood that for a stationary time series a variable at time ‘t’ is a linear function of prior observations or residual errors. Hence it is time for us to combine the two and have an Auto-regressive moving average (ARMA) model.</p>
<p>However, at times the time series is not stationary, i.e the statistical properties of a series like mean, variance changes over time. And the statistical models we have studied so far assume the time series to be stationary, therefore, we can include a pre-processing step of differencing the time series to make it stationary. Now, it is important for us to find out whether the time series we are dealing with is stationary or not.</p>
<p>Various methods to find the stationarity of a time series are looking for seasonality or trend in the plot of time series, checking the difference in mean and variance for various time periods, Augmented Dickey-Fuller (ADF) test, KPSS test, Hurst’s exponent etc.</p>
<p>Let us see whether the ‘temperature’ variable of our dataset is a stationary time series or not using ADF test.</p>
<p>In [74]:</p>
<pre class="result notranslate">
from statsmodels.tsa.stattools import adfuller

result = adfuller(train)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value In result[4].items()
   print('\t%s: %.3f' % (key, value))
</pre>
<p>ADF Statistic: -10.406056</p>
<p>p-value: 0.000000</p>
<p>Critical Values:</p>
<p>1%: -3.431</p>
<p>5%: -2.862</p>
<p>10%: -2.567</p>
<p>Now that we have run the ADF test, let us interpret the result. First we will compare the ADF Statistic with the critical values, a lower critical value tells us the series is most likely non-stationary. Next, we see the p-value. A p-value greater than 0.05 also suggests that the time series is non-stationary.</p>
<p>Alternatively, p-value less than or equal to 0.05, or ADF Statistic less than critical values suggest the time series is stationary.</p>
<p>Hence, the time series we are dealing with is already stationary. In case of stationary time series, we set the ‘d’ parameter as 0.</p>
<p>We can also confirm the stationarity of time series using Hurst exponent.</p>
<p>In [75]:</p>
<pre class="result notranslate">
import hurst

H, c,data = hurst.compute_Hc(train)
print("H = {:.4f}, c = {:.4f}".format(H,c))
</pre>
<p>H = 0.1660, c = 5.0740</p>
<p>The value of H&lt;0.5 shows anti-persistent behavior, and H&gt;0.5 shows persistent behavior or a trending series. H=0.5 shows random walk/Brownian motion. The value of H&lt;0.5, confirming that our series is stationary.</p>
<p>For non-stationary time series, we set ‘d’ parameter as 1. Also, the value of the auto-regressive trend parameter ‘p’ and the moving average trend parameter ‘q’, is calculated on the stationary time series i.e by plotting ACP and PACP after differencing the time series.</p>
<p>ARIMA Model, which is characterized by 3 parameter, (p,d,q) are now clear to us, so let us model our time series and predict the future values of temperature.</p>
<p>In [156]:</p>
<pre class="result notranslate">
from statsmodels.tsa.arima_model import ARIMA

model = ARIMA(train.values, order=(5, 0, 2))
model_fit = model.fit(disp=False)
</pre>
<p>In [157]:</p>
<pre class="result notranslate">
predictions = model_fit.predict(len(test))
test_ = pandas.DataFrame(test)
test_['predictions'] = predictions[0:1871]
</pre>
<p>In [158]:</p>
<pre class="result notranslate">
plt.plot(df['T'])
plt.plot(test_.predictions)
plt.show()
</pre>
<img class="center" src="/time_series/images/code_snippet13.jpg" alt="Code Snippet 13" />
<p>In [167]:</p>
<pre class="result notranslate">
error = sqrt(metrics.mean_squared_error(test.values,predictions[0:1871]))
print ('Test RMSE for ARIMA: ', error)
</pre>
<p>Test RMSE for ARIMA:  43.21252940234892</p>
<h1>Time Series - Variations of ARIMA</h1>
<p>In the previous chapter, we have now seen how ARIMA model works, and its limitations that it cannot handle seasonal data or multivariate time series and hence, new models were introduced to include these features.</p>
<p>A glimpse of these new models is given here &minus;</p>
<h2>Vector Auto-Regression (VAR)</h2>
<p>It is a generalized version of auto regression model for multivariate stationary time series. It is characterized by ‘p’ parameter.</p>
<h2>Vector Moving Average (VMA)</h2>
<p>It is a generalized version of moving average model for multivariate stationary time series. It is characterized by ‘q’ parameter.</p>
<h2>Vector Auto Regression Moving Average (VARMA)</h2>
<p>It is the combination of VAR and VMA and a generalized version of ARMA model for multivariate stationary time series. It is characterized by ‘p’ and ‘q’ parameters. Much like, ARMA is capable of acting like an AR model by setting ‘q’ parameter as 0 and as a MA model by setting ‘p’ parameter as 0, VARMA is also capable of acting like an VAR model by setting ‘q’ parameter as 0 and as a VMA model by setting ‘p’ parameter as 0.</p>
<p>In [209]:</p>
<pre class="result notranslate">
df_multi = df[['T', 'C6H6(GT)']]
split = len(df) - int(0.2*len(df))
train_multi, test_multi = df_multi[0:split], df_multi[split:]
</pre>
<p>In [211]:</p>
<pre class="result notranslate">
from statsmodels.tsa.statespace.varmax import VARMAX

model = VARMAX(train_multi, order = (2,1))
model_fit = model.fit()
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\tsa\statespace\varmax.py:152: 
   EstimationWarning: Estimation of VARMA(p,q) models is not generically robust, 
   due especially to identification issues. 
   EstimationWarning)
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\tsa\base\tsa_model.py:171: 
   ValueWarning: No frequency information was provided, so inferred frequency H will be used. 
  % freq, ValueWarning)
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\base\model.py:508: 
   ConvergenceWarning: Maximum Likelihood optimization failed to converge. Check mle_retvals 
  "Check mle_retvals", ConvergenceWarning)
</pre>
<p>In [213]:</p>
<pre class="result notranslate">
predictions_multi = model_fit.forecast( steps=len(test_multi))
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\tsa\base\tsa_model.py:320: 
   FutureWarning: Creating a DatetimeIndex by passing range endpoints is deprecated.  Use `pandas.date_range` instead.
   freq = base_index.freq)
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\tsa\statespace\varmax.py:152: 
   EstimationWarning: Estimation of VARMA(p,q) models is not generically robust, due especially to identification issues.
   EstimationWarning)
</pre>
<p>In [231]:</p>
<pre class="result notranslate">
plt.plot(train_multi['T'])
plt.plot(test_multi['T'])
plt.plot(predictions_multi.iloc[:,0:1], '--')
plt.show()

plt.plot(train_multi['C6H6(GT)'])
plt.plot(test_multi['C6H6(GT)'])
plt.plot(predictions_multi.iloc[:,1:2], '--')
plt.show()
</pre>
<img class="center" src="/time_series/images/code_snippet14.jpg" alt="Code Snippet 14" />
<p></p>
<img class="center" src="/time_series/images/codesnippet14.jpg" alt="Code Snippet 14" />
<p>The above code shows how VARMA model can be used to model multivariate time series, although this model may not be best suited on our data.</p>
<h2>VARMA with Exogenous Variables (VARMAX)</h2>
<p>It is an extension of VARMA model where extra variables called covariates are used to model the primary variable we are interested it.</p>
<h2>Seasonal Auto Regressive Integrated Moving Average (SARIMA)</h2>
<p>This is the extension of ARIMA model to deal with seasonal data. It divides the data into seasonal and non-seasonal components and models them in a similar fashion. It is characterized by 7 parameters, for non-seasonal part (p,d,q) parameters same as for ARIMA model and for seasonal part (P,D,Q,m) parameters where ‘m’ is the number of seasonal periods and P,D,Q are similar to parameters of ARIMA model. These parameters can be calibrated using grid search or genetic algorithm.</p>
<h2>SARIMA with Exogenous Variables (SARIMAX)</h2>
<p>This is the extension of SARIMA model to include exogenous variables which help us to model the variable we are interested in.</p>
<p>It may be useful to do a co-relation analysis on variables before putting them as exogenous variables.</p>
<p>In [251]:</p>
<pre class="result notranslate">
from scipy.stats.stats import pearsonr
x = train_multi['T'].values
y = train_multi['C6H6(GT)'].values

corr , p = pearsonr(x,y)
print ('Corelation Coefficient =', corr,'\nP-Value =',p)
Corelation Coefficient = 0.9701173437269858
P-Value = 0.0
</pre>
<p>Pearson’s Correlation shows a linear relation between 2 variables, to interpret the results, we first look at the p-value, if it is less that 0.05 then the value of coefficient is significant, else the value of coefficient is not significant. For significant p-value, a positive value of correlation coefficient indicates positive correlation, and a negative value indicates a negative correlation.</p>
<p>Hence, for our data, ‘temperature’ and ‘C6H6’ seem to have a highly positive correlation. Therefore, we will</p>
<p>In [297]:</p>
<pre class="result notranslate">
from statsmodels.tsa.statespace.sarimax import SARIMAX

model = SARIMAX(x, exog = y, order = (2, 0, 2), seasonal_order = (2, 0, 1, 1), enforce_stationarity=False, enforce_invertibility = False)
model_fit = model.fit(disp = False)
c:\users\naveksha\appdata\local\programs\python\python37\lib\site-packages\statsmodels\base\model.py:508: 
   ConvergenceWarning: Maximum Likelihood optimization failed to converge. Check mle_retvals
   "Check mle_retvals", ConvergenceWarning)
</pre>
<p>In [298]:</p>
<pre class="result notranslate">
y_ = test_multi['C6H6(GT)'].values
predicted = model_fit.predict(exog=y_)
test_multi_ = pandas.DataFrame(test)
test_multi_['predictions'] = predicted[0:1871]
</pre>
<p>In [299]:</p>
<pre class="result notranslate">
plt.plot(train_multi['T'])
plt.plot(test_multi_['T'])
plt.plot(test_multi_.predictions, '--')
</pre>
<p>Out[299]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eab0191c18&gt;]
</pre>
<p>The predictions here seem to take larger variations now as opposed to univariate ARIMA modelling.</p>
<p>Needless to say, SARIMAX can be used as an ARX, MAX, ARMAX or ARIMAX model by setting only the corresponding parameters to non-zero values.</p>
<h2>Fractional Auto Regressive Integrated Moving Average (FARIMA)</h2>
<p>At times, it may happen that our series is not stationary, yet differencing with ‘d’ parameter taking the value 1 may over-difference it. So, we need to difference the time series using a fractional value.</p>
<p>In the world of data science there is no one superior model, the model that works on your data depends greatly on your dataset. Knowledge of various models allows us to choose one that work on our data and experimenting with that model to achieve the best results. And results should be seen as plot as well as error metrics, at times a small error may also be bad, hence, plotting and visualizing the results is essential.</p>
<p>In the next chapter, we will be looking at another statistical model, exponential smoothing.</p>
<h1>Time Series - Exponential Smoothing</h1>
<p>In this chapter, we will talk about the techniques involved in exponential smoothing of time series.</p>
<h2>Simple Exponential Smoothing</h2>
<p>Exponential Smoothing is a technique for smoothing univariate time-series by assigning exponentially decreasing weights to data over a time period.</p>
<p>Mathematically, the value of variable at time ‘t+1’ given value at time t, y_(t+1|t) is defined as &minus;</p>
<p>$$y_{t+1|t}\:=\:\alpha y_{t}\:+\:\alpha\lgroup1 -\alpha\rgroup y_{t-1}\:+\alpha\lgroup1-\alpha\rgroup^{2}\:y_{t-2}\:+\:...+y_{1}$$</p>
<p>where,<span style="margin-left:7%">$0\leq\alpha \leq1$ is the smoothing parameter, and</span></p>
<p style="margin-left:15%">$y_{1},....,y_{t}$ are previous values of network traffic at times 1, 2, 3, … ,t.</p>
<p>This is a simple method to model a time series with no clear trend or seasonality. But exponential smoothing can also be used for time series with trend and seasonality.</p>
<h2>Triple Exponential Smoothing</h2>
<p>Triple Exponential Smoothing (TES) or Holt's Winter method, applies exponential smoothing three times - level smoothing $l_{t}$, trend smoothing $b_{t}$, and seasonal smoothing $S_{t}$, with $\alpha$, $\beta^{*}$ and $\gamma$ as smoothing parameters with ‘m’ as the frequency of the seasonality, i.e. the number of seasons in a year.</p>
<p>According to the nature of the seasonal component, TES has two categories &minus;</p>
<ul class="list">
<li><p><b>Holt-Winter's Additive Method</b> &minus; When the seasonality is additive in nature.</p></li>
<li><p><b>Holt-Winter’s Multiplicative Method</b> &minus; When the seasonality is multiplicative in nature.</p></li>
</ul>
<p>For non-seasonal time series, we only have trend smoothing and level smoothing, which is called Holt’s Linear Trend Method.</p>
<p>Let’s try applying triple exponential smoothing on our data.</p>
<p>In [316]:</p>
<pre class="result notranslate">
from statsmodels.tsa.holtwinters import ExponentialSmoothing

model = ExponentialSmoothing(train.values, trend= )
model_fit = model.fit()
</pre>
<p>In [322]:</p>
<pre class="result notranslate">
predictions_ = model_fit.predict(len(test))
</pre>
<p>In [325]:</p>
<pre class="result notranslate">
plt.plot(test.values)
plt.plot(predictions_[1:1871])
</pre>
<p>Out[325]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eab00f1cf8&gt;]
</pre>
<img class="center" src="/time_series/images/code_snippet17.jpg" alt="Code Snippet 17" />
<p>Here, we have trained the model once with training set and then we keep on making predictions. A more realistic approach is to re-train the model after one or more time step(s). As we get the prediction for time ‘t+1’ from training data ‘til time ‘t’, the next prediction for time ‘t+2’ can be made using the training data ‘til time ‘t+1’ as the actual value at ‘t+1’ will be known then. This methodology of making predictions for one or more future steps and then re-training the model is called rolling forecast or walk forward validation.</p>
<h1>Time Series - Walk Forward Validation</h1>
<p>In time series modelling, the predictions over time become less and less accurate and hence it is a more realistic approach to re-train the model with actual data as it gets available for further predictions. Since training of statistical models are not time consuming, walk-forward validation is the most preferred solution to get most accurate results.</p>
<p>Let us apply one step walk forward validation on our data and compare it with the results we got earlier.</p>
<p>In [333]:</p>
<pre class="result notranslate">
prediction = []
data = train.values
for t In test.values:
   model = (ExponentialSmoothing(data).fit())
   y = model.predict()
   prediction.append(y[0])
   data = numpy.append(data, t)
</pre>
<p>In [335]:</p>
<pre class="result notranslate">
test_ = pandas.DataFrame(test)
test_['predictionswf'] = prediction
</pre>
<p>In [341]:</p>
<pre class="result notranslate">
plt.plot(test_['T'])
plt.plot(test_.predictionswf, '--')
plt.show()
</pre>
<img class="center" src="/time_series/images/code_snippet18.jpg" alt="Code Snippet 18" />
<p>In [340]:</p>
<pre class="result notranslate">
error = sqrt(metrics.mean_squared_error(test.values,prediction))
print ('Test RMSE for Triple Exponential Smoothing with Walk-Forward Validation: ', error)
Test RMSE for Triple Exponential Smoothing with Walk-Forward Validation:  11.787532205759442
</pre>
<p>We can see that our model performs significantly better now. In fact, the trend is followed so closely that on the plot predictions are overlapping with the actual values. You can try applying walk-forward validation on ARIMA models too.</p>
<h1>Time Series - Prophet Model</h1>
<p>In 2017, Facebook open sourced the prophet model which was capable of modelling the time series with strong multiple seasonalities at day level, week level, year level etc. and trend. It has intuitive parameters that a not-so-expert data scientist can tune for better forecasts. At its core, it is an additive regressive model which can detect change points to model the time series.</p>
<p>Prophet decomposes the time series into components of trend $g_{t}$, seasonality $S_{t}$ and holidays $h_{t}$.</p>
<p>$$y_{t}=g_{t}+s_{t}+h_{t}+\epsilon_{t}$$</p>
<p>Where, <span style="margin-left:28%;">$\epsilon_{t}$ is the error term.</span></p>
<p>Similar packages for time series forecasting such as causal impact and anomaly detection were introduced in R by google and twitter respectively.</p>
<h1>Time Series - LSTM Model</h1>
<p>Now, we are familiar with statistical modelling on time series, but machine learning is all the rage right now, so it is essential to be familiar with some machine learning models as well. We shall start with the most popular model in time series domain &minus; Long Short-term Memory model.</p>
<p>LSTM is a class of recurrent neural network. So before we can jump to LSTM, it is essential to understand neural networks and recurrent neural networks.</p>
<h2>Neural Networks</h2>
<p>An artificial neural network is a layered structure of connected neurons, inspired by biological neural networks. It is not one algorithm but combinations of various algorithms which allows us to do complex operations on data.</p>
<h2>Recurrent Neural Networks</h2>
<p>It is a class of neural networks tailored to deal with temporal data. The neurons of RNN have a cell state/memory, and input is processed according to this internal state, which is achieved with the help of loops with in the neural network. There are recurring module(s) of ‘tanh’ layers in RNNs that allow them to retain information. However, not for a long time, which is why we need LSTM models.</p>
<h2>LSTM</h2>
<p>It is special kind of recurrent neural network that is capable of learning long term dependencies in data. This is achieved because the recurring module of the model has a combination of four layers interacting with each other.</p>
<img class="full-width" src="/time_series/images/neural_network.jpg" alt="Neural Network" />
<p>The picture above depicts four neural network layers in yellow boxes, point wise operators in green circles, input in yellow circles and cell state in blue circles. An LSTM module has a cell state and three gates which provides them with the power to selectively learn, unlearn or retain information from each of the units. The cell state in LSTM helps the information to flow through the units without being altered by allowing only a few linear interactions. Each unit has an input, output and a forget gate which can add or remove the information to the cell state. The forget gate decides which information from the previous cell state should be forgotten for which it uses a sigmoid function. The input gate controls the information flow to the current cell state using a point-wise multiplication operation of ‘sigmoid’ and ‘tanh’ respectively. Finally, the output gate decides which information should be passed on to the next hidden state</p>
<p>Now that we have understood the internal working of LSTM model, let us implement it. To understand the implementation of LSTM, we will start with a simple example &minus; a straight line. Let us see, if LSTM can learn the relationship of a straight line and predict it.</p>
<p>First let us create the dataset depicting a straight line.</p>
<p>In [402]:</p>
<pre class="result notranslate">
x = numpy.arange (1,500,1)
y = 0.4 * x + 30
plt.plot(x,y)
</pre>
<p>Out[402]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eab9d3ee10&gt;]
</pre>
<img class="center" src="/time_series/images/code_snippet19.jpg" alt="Code Snippet 19" />
<p>In [403]:</p>
<pre class="result notranslate">
trainx, testx = x[0:int(0.8*(len(x)))], x[int(0.8*(len(x))):]
trainy, testy = y[0:int(0.8*(len(y)))], y[int(0.8*(len(y))):]
train = numpy.array(list(zip(trainx,trainy)))
test = numpy.array(list(zip(trainx,trainy)))
</pre>
<p>Now that the data has been created and split into train and test. Let’s convert the time series data into the form of supervised learning data according to the value of look-back period, which is essentially the number of lags which are seen to predict the value at time ‘t’.</p>
<p>So a time series like this &minus;</p>
<pre class="result notranslate">
time variable_x
t1  x1
t2  x2
 :   :
 :   :
T   xT
</pre>
<p>When look-back period is 1, is converted to &minus;</p>
<pre class="result notranslate">
x1   x2
x2   x3
 :    :
 :    :
xT-1 xT
</pre>
<p>In [404]:</p>
<pre class="result notranslate">
def create_dataset(n_X, look_back):
   dataX, dataY = [], []
   for i in range(len(n_X)-look_back):
      a = n_X[i:(i+look_back), ]
      dataX.append(a)
      dataY.append(n_X[i + look_back, ])
   return numpy.array(dataX), numpy.array(dataY)
</pre>
<p>In [405]:</p>
<pre class="result notranslate">
look_back = 1
trainx,trainy = create_dataset(train, look_back)
testx,testy = create_dataset(test, look_back)

trainx = numpy.reshape(trainx, (trainx.shape[0], 1, 2))
testx = numpy.reshape(testx, (testx.shape[0], 1, 2))
</pre>
<p>Now we will train our model.</p>
<p>Small batches of training data are shown to network, one run of when entire training data is shown to the model in batches and error is calculated is called an epoch. The epochs are to be run ‘til the time the error is reducing.</p>
<p>In [ ]:</p>
<pre class="result notranslate">
from keras.models import Sequential
from keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(256, return_sequences = True, input_shape = (trainx.shape[1], 2)))
model.add(LSTM(128,input_shape = (trainx.shape[1], 2)))
model.add(Dense(2))
model.compile(loss = 'mean_squared_error', optimizer = 'adam')
model.fit(trainx, trainy, epochs = 2000, batch_size = 10, verbose = 2, shuffle = False)
model.save_weights('LSTMBasic1.h5')
</pre>
<p>In [407]:</p>
<pre class="result notranslate">
model.load_weights('LSTMBasic1.h5')
predict = model.predict(testx)
</pre>
<p>Now let’s see what our predictions look like.</p>
<p>In [408]:</p>
<pre class="result notranslate">
plt.plot(testx.reshape(398,2)[:,0:1], testx.reshape(398,2)[:,1:2])
plt.plot(predict[:,0:1], predict[:,1:2])
</pre>
<p>Out[408]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eac792f048&gt;]
</pre>
<img class="center" src="/time_series/images/code_snippet22.jpg" alt="Code Snippet 22" />
<p>Now, we should try and model a sine or cosine wave in a similar fashion. You can run the code given below and play with the model parameters to see how the results change.</p>
<p>In [409]:</p>
<pre class="result notranslate">
x = numpy.arange (1,500,1)
y = numpy.sin(x)
plt.plot(x,y)
</pre>
<p>Out[409]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eac7a0b3c8&gt;]
</pre>
<img class="center" src="/time_series/images/code_snippet23.jpg" alt="Code Snippet 23" />
<p>In [410]:</p>
<pre class="result notranslate">
trainx, testx = x[0:int(0.8*(len(x)))], x[int(0.8*(len(x))):]
trainy, testy = y[0:int(0.8*(len(y)))], y[int(0.8*(len(y))):]
train = numpy.array(list(zip(trainx,trainy)))
test = numpy.array(list(zip(trainx,trainy)))
</pre>
<p>In [411]:</p>
<pre class="result notranslate">
look_back = 1
trainx,trainy = create_dataset(train, look_back)
testx,testy = create_dataset(test, look_back)
trainx = numpy.reshape(trainx, (trainx.shape[0], 1, 2))
testx = numpy.reshape(testx, (testx.shape[0], 1, 2))
</pre>
<p>In [ ]:</p>
<pre class="result notranslate">
model = Sequential()
model.add(LSTM(512, return_sequences = True, input_shape = (trainx.shape[1], 2)))
model.add(LSTM(256,input_shape = (trainx.shape[1], 2)))
model.add(Dense(2))
model.compile(loss = 'mean_squared_error', optimizer = 'adam')
model.fit(trainx, trainy, epochs = 2000, batch_size = 10, verbose = 2, shuffle = False)
model.save_weights('LSTMBasic2.h5')
</pre>
<p>In [413]:</p>
<pre class="result notranslate">
model.load_weights('LSTMBasic2.h5')
predict = model.predict(testx)
</pre>
<p>In [415]:</p>
<pre class="result notranslate">
plt.plot(trainx.reshape(398,2)[:,0:1], trainx.reshape(398,2)[:,1:2])
plt.plot(predict[:,0:1], predict[:,1:2])
</pre>
<p>Out [415]:</p>
<pre class="result notranslate">
[&lt;matplotlib.lines.Line2D at 0x1eac7a1f550&gt;]
</pre>
<img class="center" src="/time_series/images/codesnippet23.jpg" alt="Code Snippet 23" />
<p>Now you are ready to move on to any dataset.</p>
<h1>Time Series - Error Metrics</h1>
<p>It is important for us to quantify the performance of a model to use it as a feedback and comparison. In this tutorial we have used one of the most popular error metric root mean squared error. There are various other error metrics available. This chapter discusses them in brief.</p>
<h2>Mean Square Error</h2>
<p>It is the average of square of difference between the predicted values and true values. Sklearn provides it as a function. It has the same units as the true and predicted values squared and is always positive.</p>
<p>$$MSE = \frac{1}{n} \displaystyle\sum\limits_{t=1}^n \lgroup y'_{t}\:-y_{t}\rgroup^{2}$$</p>
<p>Where <span style="margin-left:7%">$y'_{t}$ is the predicted value,</span></p>
<p style="margin-left:15%">$y_{t}$ is the actual value, and</p>
<p style="margin-left:15%">n is the total number of values in test set.</p>
<p>It is clear from the equation that MSE is more penalizing for larger errors, or the outliers.</p>
<h2>Root Mean Square Error</h2>
<p>It is the square root of the mean square error. It is also always positive and is in the range of the data.</p>
<p>$$RMSE = \sqrt{\frac{1}{n} \displaystyle\sum\limits_{t=1}^n \lgroup y'_{t}-y_{t}\rgroup ^2}$$</p>
<p>Where, <span style="margin-left:6%">$y'_{t}$ is predicted value</span></p>
<p style="margin-left:15%">$y_{t}$ is actual value, and</p>
<p style="margin-left:15%">n is total number of values in test set.</p>
<p>It is in the power of unity and hence is more interpretable as compared to MSE. RMSE is also more penalizing for larger errors. We have used RMSE metric in our tutorial.</p>
<h2>Mean Absolute Error</h2>
<p>It is the average of absolute difference between predicted values and true values. It has the same units as predicted and true value and is always positive.</p>
<p>$$MAE = \frac{1}{n}\displaystyle\sum\limits_{t=1}^{t=n} | y'{t}-y_{t}\lvert$$</p>
<p>Where, <span style="margin-left:6%">$y'_{t}$ is predicted value,</span></p>
<p style="margin-left:15%">$y_{t}$ is actual value, and</p>
<p style="margin-left:15%">n is total number of values in test set.</p>
<h2>Mean Percentage Error</h2>
<p>It is the percentage of average of absolute difference between predicted values and true values, divided by the true value.</p>
<p>$$MAPE = \frac{1}{n}\displaystyle\sum\limits_{t=1}^n\frac{y'_{t}-y_{t}}{y_{t}}*100\: \%$$</p>
<p>Where, <span style="margin-left:6%">$y'_{t}$ is predicted value,</span></p>
<p style="margin-left:15%">$y_{t}$ is actual value and n is total number of values in test set.</p>
<p>However, the disadvantage of using this error is that the positive error and negative errors can offset each other. Hence mean absolute percentage error is used.</p>
<h2>Mean Absolute Percentage Error</h2>
<p>It is the percentage of average of absolute difference between predicted values and true values, divided by the true value.</p>
<p>$$MAPE = \frac{1}{n}\displaystyle\sum\limits_{t=1}^n\frac{|y'_{t}-y_{t}\lvert}{y_{t}}*100\: \%$$</p>
<p>Where <span style="margin-left:7%">$y'_{t}$ is predicted value</span></p>
<p style="margin-left:15%">$y_{t}$ is actual value, and</p>
<p style="margin-left:15%">n is total number of values in test set.</p>
<h1>Time Series - Applications</h1>
<p>We discussed time series analysis in this tutorial, which has given us the understanding that time series models first recognize the trend and seasonality from the existing observations and then forecast a value based on this trend and seasonality. Such analysis is useful in various fields such as &minus;</p>
<ul class="list">
<li><p><b>Financial Analysis</b> &minus; It includes sales forecasting, inventory analysis, stock market analysis, price estimation.</p></li>
<li><p><b>Weather Analysis</b> &minus; It includes temperature estimation, climate change, seasonal shift recognition, weather forecasting.</p></li>
<li><p><b>Network Data Analysis</b> &minus; It includes network usage prediction, anomaly or intrusion detection, predictive maintenance.</p></li>
<li><p><b>Healthcare Analysis</b> &minus; It includes census prediction, insurance benefits prediction, patient monitoring.</p></li>
</ul>
<h1>Time Series - Further Scope</h1>
<p>Machine learning deals with various kinds of problems. In fact, almost all fields have a scope to be automatized or improved with the help of machine learning. A few such problems on which a great deal of work is being done are given below.</p>
<h2>Time Series Data</h2>
<p>This is the data which changes according to time, and hence time plays a crucial role in it, which we largely discussed in this tutorial.</p>
<h2>Non-Time Series Data</h2>
<p>It is the data independent of time, and a major percentage of ML problems are on nontime series data. For simplicity, we shall categorize it further as &minus;</p>
<ul class="list">
<li><p><b>Numerical Data</b> &minus; Computers, unlike humans, only understand numbers, so all kinds of data ultimately is converted to numerical data for machine learning, for example, image data is converted to (r,b,g) values, characters are converted to ASCII codes or words are indexed to numbers, speech data is converted to mfcc files containing numerical data.</p></li>
<li><p><b>Image Data</b> &minus; Computer vision has revolutionized the world of computers, it has various application in the field of medicine, satellite imaging etc.</p></li>
<li><p><b>Text Data</b> &minus; Natural Language Processing (NLP) is used for text classification, paraphrase detection and language summarization. This is what makes Google and Facebook smart.</p></li>
<li><p><b>Speech Data</b> &minus; Speech Processing involves speech recognition and sentiment understanding. It plays a crucial role in imparting computers the human-like qualities.</p></li>
</ul>
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/time_series/time_series_further_scope.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/time_series/time_series_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
