<!DOCTYPE html>
<html lang="en-US">
<head>
<title>BabylonJS - Quick Guide</title>
<meta charset="utf-8">
<meta name="description" content="BabylonJS - Quick Guide - Babylon.js is a javascript open-source framework which is used to develop 3D applications/ video games for the web. The official website of BabylonJS is www.bab"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/babylonjs/babylonjs_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#3C789A;
}
a.demo {
    background:#3C789A;
}
li.heading {
    background:#3C789A;
}
.course-box{background:#3C789A}
.home-intro-sub p{color:#3C789A}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/babylonjs/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<div class="mini-logo">
<img src="/babylonjs/images/babylonjs-mini-logo.jpg" alt="BabylonJS Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">BabylonJS Tutorial</li>
<li><a href="/babylonjs/index.htm">BabylonJS - Home</a></li>
<li><a href="/babylonjs/babylonjs_introduction.htm">BabylonJS - Introduction</a></li>
<li><a href="/babylonjs/babylonjs_environment_setup.htm">BabylonJS - Environment Setup</a></li>
<li><a href="/babylonjs/babylonjs_overview.htm">BabylonJS - Overview</a></li>
<li><a href="/babylonjs/babylonjs_basic_elements.htm">BabylonJS - Basic Elements</a></li>
<li><a href="/babylonjs/babylonjs_materials.htm">BabylonJS - Materials</a></li>
<li><a href="/babylonjs/babylonjs_animations.htm">BabylonJS - Animations</a></li>
<li><a href="/babylonjs/babylonjs_cameras.htm">BabylonJS - Cameras</a></li>
<li><a href="/babylonjs/babylonjs_lights.htm">BabylonJS - Lights</a></li>
<li><a href="/babylonjs/babylonjs_parametric_shapes.htm">BabylonJS - Parametric Shapes</a></li>
<li><a href="/babylonjs/babylonjs_mesh.htm">BabylonJS - Mesh</a></li>
<li><a href="/babylonjs/babylonjs_vectorposition_and_rotation.htm">VectorPosition and Rotation</a></li>
<li><a href="/babylonjs/babylonjs_decals.htm">BabylonJS - Decals</a></li>
<li><a href="/babylonjs/babylonjs_curve3.htm">BabylonJS - Curve3</a></li>
<li><a href="/babylonjs/babylonjs_dynamic_texture.htm">BabylonJS - Dynamic Texture</a></li>
<li><a href="/babylonjs/babylonjs_parallax_mapping.htm">BabylonJS - Parallax Mapping</a></li>
<li><a href="/babylonjs/babylonjs_lens_flares.htm">BabylonJS - Lens Flares</a></li>
<li><a href="/babylonjs/babylonjs_create_screenshot.htm">BabylonJS - Create ScreenShot</a></li>
<li><a href="/babylonjs/babylonjs_reflection_probes.htm">BabylonJS - Reflection Probes</a></li>
<li><a href="/babylonjs/babylonjs_standard_rendering_pipeline.htm">Standard Rendering Pipeline</a></li>
<li><a href="/babylonjs/babylonjs_shadermaterial.htm">BabylonJS - ShaderMaterial</a></li>
<li><a href="/babylonjs/babylonjs_bones_and_skeletons.htm">BabylonJS - Bones and Skeletons</a></li>
<li><a href="/babylonjs/babylonjs_physics_engine.htm">BabylonJS - Physics Engine</a></li>
<li><a href="/babylonjs/babylonjs_playing_sounds_and_music.htm">BabylonJS - Playing Sounds &amp; Music</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">BabylonJS Useful Resources</li>
<li><a href="/babylonjs/babylonjs_quick_guide.htm">BabylonJS - Quick Guide</a></li>
<li><a href="/babylonjs/babylonjs_useful_resources.htm">BabylonJS - Useful Resources</a></li>
<li><a href="/babylonjs/babylonjs_discussion.htm">BabylonJS - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>BabylonJS - Quick Guide</h1>
<hr />
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/babylonjs/babylonjs_playing_sounds_and_music.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/babylonjs/babylonjs_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>BabylonJS - Introduction</h1>
<p>Babylon.js is a javascript open-source framework which is used to develop 3D applications/ video games for the web. The official website of BabylonJS is <a href="https://www.babylonjs.com/" target="_blank" rel="nofollow">www.babylonjs.com</a>.</p>
<p>Using Babylon.js framework is easy for the users. It contains all the required tools to create and manage 3D objects, special effects, and sounds, etc.</p>
<p>Babylon.js is one of the most popular 3D game engines and is widely used by developers. Being a 3D library, it provides built-in functions. These functions help you implement common 3D functionality with efficient and accurate ways.</p>
<p>It is developed using TypeScript language based on WebGL and javascript.</p>
<h2>What is WebGL?</h2>
<p>WebGL (Web Graphics Library) is the new standard for 3D graphics on the Web. It is designed for the purpose of rendering 2D graphics and interactive 3D graphics. It is derived from OpenGL's ES 2.0 library which is a low-level 3D API for phones and other mobile devices. WebGL provides similar functionality of ES 2.0 (Embedded Systems) and performs well on modern 3D graphics hardware.</p>
<h2>The TypeScript</h2>
<p>By definition, “TypeScript is JavaScript for application-scale development.”</p>
<p>TypeScript is a strongly typed, object oriented, compiled language. TypeScript is both a language and a set of tools. TypeScript is a typed superset of JavaScript compiled to JavaScript. In other words, TypeScript is JavaScript plus some additional features.</p>
<p>The goal of TypeScript language is to improve and secure the production of JavaScript code.Since BabylonJS is developed using TypScript, it is robust and secure.</p>
<h1>BabylonJS - Environment Setup</h1>
<p>In this chapter, we will learn how to set up the environment for BabylonJS.</p>
<p>To start with the setup, visit the official website of Babylon.js &minus; <a href="https://www.babylonjs.com/" target="_blank" rel="nofollow">www.babylonjs.com</a>. Go to the download section and choose the latest version of Babylon.js and store in your folder.</p>
<p>The screenshot for the same is as follows &minus;</p>
<img src="/babylonjs/images/babylonjs_website_screenshot.jpg" alt="BabylonJS Website Screenshot" />
<p>You can also go to GITHUB and clone the babylonjs project &minus;</p>
<p><a href="https://github.com/BabylonJS/Babylon.js.git" target="_blank" rel="nofollow">Babylon.js</a></p>
<p>In your command line type  &minus;</p>
<pre class="result notranslate">
git clone <b><a href="https://github.com/BabylonJS/Babylon.js.git" target="_blank" rel="nofollow">https://github.com/BabylonJS/Babylon.js.git</a></b>
go to cd BabylonJS/
npm install
</pre>
<p>The required files will be available in the BabylonJS folder.</p>
<p>You can use the VSCode (Microsoft Visual Studio Code) for editing.The code comes with builtin functionalities like highlighting if any error, hightlighting the syntax, etc. You can use the editor of your choice and it is not mandatory to use only VSCode.</p>
<h1>BabylonJS - Overview</h1>
<p><b>BabylonJS</b> is an open sourceJavascript framework for building 3D games with HTML5 and WEBGL.It is hosted on github.The official web site of BabylonJS is <a href="https://www.babylonjs.com/" target="_blank" rel="nofollow">www.babylonjs.com.</a></p>
<p>In the world of 3D Animation,the shapes are drawn with triangles.With WebGL, the complexity increases with the deluge of coding that is involved in the process. BabylonJS is the easy solution that pitches in to mitigate the increased complexity. Here, the API for lights, cameras, engine are easy to handle and to create 3D objects.</p>
<p>The source code of babylonJS is coded in typescript.It is compiled to Javascript and made available tothe end user.</p>
<p>To start working with Babylonjs, download the babylonjs file, host it at your end and you are ready to get started to write your 3D code.</p> 
<p>BabylonJS is developed by Microsoft employees in the year 2016.David Catuhe, a Principal Program Manager for the Window &amp; Devices Group at Microsoft is the main person behind developing BabylonJs and making it a big success.</p>
<p>To run BabylonJS, we need modern browsers with WEBGL support. Latest browsers i.e Internet Explorer 11+, Firefox 4+, Google Chrome 9+, Opera 15+, etc. does have WEBGL support and the demos can be executed on same to see the output.</p>
<p>BabylonJs offers following features which help to create different types of 3D-scenes &minus;</p>
<ul class="list">
<li>Shapes like box, sphere, scylinder, cone, height ground</li>
<li>Cameras, Lights</li>
<li>Meshes, textures, Materials</li>
<li>Sprites</li>
<li>Morphing</li>
<li>Mesh Intersection and collision detection</li>
<li>Physics engine plug-in</li>
<li>Action Manager</li>
<li>SolidParticles</li>
<li>Instances and Particles</li>
<li>Support for Bones and Skeletons</li>
<li>Adding music and sound to the scene</li>
</ul>
<p>In addition to its own meshes, BabylonJS also allows the use of meshes created from third party 3D softwares like Blender, FBX and 3DS Max.</p>
<h2>Blender</h2>
<p>Blender is an open-source 3D computer graphics software product used to create animated scenes, 3D printed models, video games, etc. Blender gives. bablyon files which are to be used with Babylon to render meshes. How to convert files from blender to babylon is explained in subsequent chapters of this tutorial.</p>
<h2>FBX</h2>
<p>Also called the filmbox, it helps with 3D animation and texture painting software. The FBX files are saved with the.fbx extension.</p>
<h2>MAX</h2>
<p>The MAX software helps you in creating massive world in games, stunning scenes for designs and engaging virtual reality experiences.</p>
<h1>BabylonJS - Basic Elements</h1>
<p>Babylon.js is a popular framework to help build 3D games for developers. It has built-in functions to implement 3D functionalities. Let us build a simple demo using Babylon.js and understand the basic functionalities required to get started.</p>
<p>We will first create a demo which contains the basic elements of Babylon.js. In addition, we will also learn the various functionalities of Babylon.js.</p>
<h2>Sample Demo 1</h2>
<p>In this section, we will learn how to create a demo containing the basic elements of BabylonJS.</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt; Babylon.JS : Demo2&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas { width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            scene.activeCamera.attachControl(canvas);
            
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 0, 10), scene);
            
            var origin = BABYLON.Mesh.CreateSphere("origin", 10, 1.0, scene);
            
            var torus = BABYLON.Mesh.CreateTorus("torus", 5, 1, 10, scene, false);
            
            var box = BABYLON.Mesh.CreateBox("box", 3.0, scene);
            box.position = new BABYLON.Vector3(-5, 0, 0); 
            
            var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 3, 3, 3, 6, 1, scene, false);
            
            cylinder.position = new BABYLON.Vector3(5, 0, 0);	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<img src="/babylonjs/images/babylonjs_basic_elements.jpg" alt="Babylonjs Basic Elements" />
<p>To run BabylonJS, we need modern browsers with WEBGL support. The latest browsers -Internet Explorer 11+, Firefox 4+, Google Chrome 9+, Opera 15+, etc. does have WEBGL support and the demos can be executed on the same platforms to see the output. Create a directory to store the files for babylonjs. Fetch the latest BabylonJSscripts file from BabylonJS site. All the demo links in this tutorial are tested with babylonjs version 3.3.</p>
<h3>Step 1</h3>
<ul class="list">
<li><p>Create a simple html page and include the Babylon.js file.</p></li>
<li><p>Create a canvas tag which is used to render contents by BabylonJSinside the body tag as shown below.</p></li> 
<li><p>Add css to the canvas to occupy the full width and height of the screen.</p></li>
</ul>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;MDN Games: Babylon.js demo - shapes&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Step 2</h3>
<p>Let us now start with the BabylonJScode for rendering contents on the canvas.</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;MDN Games: Babylon.js demo - shapes&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Now, add the script tag to the html structure and store the canvas reference in variable canvas.</p>
<p>To get started with Babylon.js, create an engine instance and pass the canvas reference to render on it.</p>
<pre class="prettyprint notranslate">
&lt;script type = "text/javascript"&gt;
   var canvas = document.getElementById("renderCanvas");
   var engine = new BABYLON.Engine(canvas, true);
&lt;/script&gt;
</pre>
<p>The BABYLON global object contains all the Babylon.js functions available in the engine.</p>
<h3>Step 3</h3>
<p>In this step, we will first create a scene.</p>
<p>A scene is where all the contents will be displayed. We will create the different types of objects and add the same to the scene to make it visible on the screen. To create scene, add the following code to the already created html structure. At present, we will append to the already created code as a continuation to the above html structure.</p>
<pre class="prettyprint notranslate">
var createScene  = function() {
   var scene = new BABYLON.Scene(engine);
   scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
};
var scene = createScene();
</pre>
<p>The final html file will look as follows &minus;</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;MDN Games: Babylon.js demo - shapes&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            return scene;
         };
         var scene = createScene();
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>In the above example, the CreateScene function is defined and the var scene = createScene () is calling the function.</p>
<p>The CreateScene function has the scene created inside it and the next line adds color to the scene, which is done using BABYLON.Color3(1, 0.8, 0.8) and the color over here is pink.</p>
<pre class="result notranslate">
var scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
</pre>
<p>Executing the above demo link in the browser will not display anything right now on the browser screen. There is one more step to be added to the code which is called the engine.runRenderLoop as in step 4.</p>
<h3>Step 4</h3>
<p>To make the scene actually visible on the screen, we need to render it using engine.runRenderLoop call. Let us now see how this is done.</p>
<h3>Rendering Loop</h3>
<pre class="result notranslate">
engine.runRenderLoop(function() {
   scene.render();
});
</pre>
<p>The Engine.runRenderLoop function calls scene.render, which will render the scene and make it visible to the user. The final .html will look as follows &minus;</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Save the above file as basicscene.html and check the output in the browser. The screen that is shown is in pink color as shown below &minus;</p>
<img src="/babylonjs/images/pink_output_browser_screen.jpg" alt="Pink Output Browser Screen" />
<h3>Step 5</h3>
<p>Now that we have the scene, we have to add camera to it.</p>
<h3>Adding Camera and Light</h3>
<p>The code given below adds camera to the scene. There are many types of camera that can be used on Babylon.</p>
<p><b>ArcRotateCamera</b> is a camera that rotates around the target. It can be controlled with mouse, cursor or touch events. The parameters required are name, alpha, beta, radius, target, and scene. Let us discuss the details of the camera in a subsequent section.</p>
<pre class="prettyprint notranslate">
var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
</pre>
<p>Now, we need to understand how to add light.</p> 
<p>Lights are used to produce the diffuse and specular color received by each pixel. There are many types of lights. We will learn about the different types of lights in the lights section.</p>
<p>Here I am using the PointLight on the scene. The PointLight is emitted in every direction like theSun. The parameters are name, position and the scene to be used on.</p>
<p>To add light, execute the following code &minus;</p>
<pre class="result notranslate">
var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 0, 10), scene);
</pre>
<h3>Step 6</h3>
<p>Let us now see how to add shapes.</p>
<h3>Adding of shapes</h3>
<p>The demo shared above has 4 shapes added to it.</p>
<ul class="list">
<li>Sphere</li>
<li>Torus</li>
<li>Box</li>
<li>Cylinder</li>
</ul>
<p>To add sphere, execute the following code &minus;</p>
<pre class="result notranslate">
var origin = BABYLON.Mesh.CreateSphere("origin", 10, 1.0, scene);
</pre>
<p>Once the sphere is added, the code looks as follows &minus;</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;MDN Games: Babylon.js demo - shapes&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 0, 10), scene);
            var origin = BABYLON.Mesh.CreateSphere("origin", 10, 1.0, scene);
            scene.activeCamera.attachControl(canvas);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above code generates the following output &minus;</p>
<img src="/babylonjs/images/scenesphere.jpg" alt="Scenesphere" />
<p>Let us now add the other shapes – the Torus and the Box. Execute the following code to add the Torus shape.</p>
<pre class="prettyprint notranslate">
var torus = BABYLON.Mesh.CreateTorus("torus", 5, 1, 10, scene, false);
var box = BABYLON.Mesh.CreateBox("box", 3.0, scene);
box.position = new BABYLON.Vector3(-5, 0, 0);
</pre>
<p>We will add a position to the box. BABYLON.Vector3(-5, 0, 0) takes the x,y and z direction.</p>
<p>Upon execution, the above code generates the following output &minus;</p>
<img src="/babylonjs/images/torus_shape.jpg" alt="Torus shape" />
<p>Let us now add the final shape which is shown in the screenshot above - the cylinder.</p>
<pre class="result notranslate">
var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 3, 3, 3, 6, 1, scene, false);
cylinder.position = new BABYLON.Vector3(5, 0, 0);
</pre>
<p>The position is added to the cylinder which is x direction 5. The final code is as shown below &minus;</p>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt; Babylon.JS : Demo2&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas { width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 0.8, 0.8);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            scene.activeCamera.attachControl(canvas);
            
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 0, 10), scene);
            
            var origin = BABYLON.Mesh.CreateSphere("origin", 10, 1.0, scene);
            
            var torus = BABYLON.Mesh.CreateTorus("torus", 5, 1, 10, scene, false);
            
            var box = BABYLON.Mesh.CreateBox("box", 3.0, scene);
            box.position = new BABYLON.Vector3(-5, 0, 0); 
            
            var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 3, 3, 3, 6, 1, scene, false);
            cylinder.position = new BABYLON.Vector3(5, 0, 0);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>Upon execution, the above code will generate the following output &minus;</p>
<img src="/babylonjs/images/basic_elements_shapes.jpg" alt="Basic Elements shapes" />
<p>The shapes will move as per the direction you move the cursor; the same is done using the attach control of the camera to the scene.</p>
<pre class="result notranslate">
scene.activeCamera.attachControl(canvas);
</pre>
<p>Let us now discuss each shape in detail.</p>
<p>Here is the summary of all the shapes and the syntax &minus;</p>
<table class="table table-bordered" style="width:100%;">
<tr>
<th style="text-align:center;">Sr.No</th>
<th style="text-align:center;">Shape</th>
<th style="text-align:center;">Syntax</th>
</tr>
<tr>
<td class="ts">1</td>
<td class="ts"><a href="/babylonjs/babylonjs_box.htm">Box</a></td>
<td><pre class="result notranslate">var box = BABYLON.Mesh.CreateBox(
   "box", 6.0, scene, false, BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">2</td>
<td class="ts"><a href="/babylonjs/babylonjs_sphere.htm">Sphere</a></td>
<td><pre class="result notranslate">var sphere = BABYLON.Mesh.CreateSphere(
   "sphere", 10.0, 10.0, scene, 
   false, BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">3</td>
<td class="ts"><a href="/babylonjs/babylonjs_plane.htm">Plane</a></td>
<td><pre class="result notranslate">var plane = BABYLON.Mesh.CreatePlane(
   "plane", 10.0, scene, false, BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">4</td>
<td class="ts"><a href="/babylonjs/babylonjs_disc.htm">Disc</a></td>
<td><pre class="result notranslate">var disc = BABYLON.Mesh.CreateDisc(
   "disc", 5, 30, scene, false, BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">5</td>
<td class="ts"><a href="/babylonjs/babylonjs_cylinder.htm">Cylinder</a></td>
<td><pre class="result notranslate">var cylinder = BABYLON.Mesh.CreateCylinder(
   "cylinder", 3, 3, 3, 6, 1, scene, false, 
   BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">6</td>
<td class="ts"><a href="/babylonjs/babylonjs_torus.htm">Torus</a></td>
<td><pre class="result notranslate">var torus = BABYLON.Mesh.CreateTorus(
   "torus", 5, 1, 10, scene, false, 
   BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">7</td>
<td class="ts"><a href="/babylonjs/babylonjs_knot.htm">Knot</a></td>
<td><pre class="result notranslate">var knot = BABYLON.Mesh.CreateTorusKnot(
   "knot", 2, 0.5, 128, 64, 2, 3, scene, false, 
   BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">8</td>
<td class="ts"><a href="/babylonjs/babylonjs_line_mesh.htm">Line Mesh</a></td>
<td><pre class="result notranslate">
var lines = BABYLON.Mesh.CreateLines("lines", [
   new BABYLON.Vector3(-10, 0, 0),
   new BABYLON.Vector3(10, 0, 0),
   new BABYLON.Vector3(0, 0, -10),
   new BABYLON.Vector3(0, 0, 10)
], scene);
</pre></td>
</tr>
<tr>
<td class="ts">9</td>
<td class="ts"><a href="/babylonjs/babylonjs_dashedlines_mesh.htm">Dashes Lines</a></td>
<td><pre class="result notranslate">var dashedlines = BABYLON.Mesh.CreateDashedLines(
   "dashedLines", [v1, v2, ... vn], 
   dashSize, gapSize, dashNb, scene);</pre></td>
</tr>
<tr>
<td class="ts">10</td>
<td class="ts"><a href="/babylonjs/babylonjs_ribbon.htm">Ribbon</a></td>
<td><pre class="result notranslate">var ribbon = BABYLON.Mesh.CreateRibbon(
   "ribbon", 
   [path1, path2, ..., pathn], 
   false, false, 0, 
   scene, false, 
   BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">11</td>
<td class="ts"><a href="/babylonjs/babylonjs_tube.htm">Tube</a></td>
<td><pre class="result notranslate">var tube = BABYLON.Mesh.CreateTube(
   "tube", 
   [V1, V2, ..., Vn], 
   radius, tesselation, 
   radiusFunction, 
   cap, scene, false, 
   BABYLON.Mesh.DEFAULTSIDE);</pre></td>
</tr>
<tr>
<td class="ts">12</td>
<td class="ts"><a href="/babylonjs/babylonjs_ground.htm">Ground</a></td>
<td><pre class="result notranslate">var ground = BABYLON.Mesh.CreateGround(
   "ground", 6, 6, 2, scene);</pre></td>
</tr>
<tr>
<td class="ts">13</td>
<td class="ts"><a href="/babylonjs/babylonjs_ground_from_heightmap.htm">Ground From HeightMap</a></td>
<td><pre class="result notranslate">var ground = BABYLON.Mesh.CreateGroundFromHeightMap(
   "ground", "heightmap.jpg", 200, 200, 250, 0, 10, 
   scene, false, successCallback);</pre></td>
</tr>
<tr>
<td class="ts">14</td>
<td class="ts"><a href="/babylonjs/babylonjs_tiled_ground.htm">Tiled Ground</a></td>
<td><pre class="result notranslate">var precision = {"w" : 2, "h" : 2};
var subdivisions = {'h' : 8, 'w' : 8};
var tiledGround = BABYLON.Mesh.CreateTiledGround(
   "Tiled Ground", -3, -3, 3, 3, 
   subdivisions, precision, scene, false);
</pre>
</td>
</tr>
</table>
<h2>Basic Element - Position, Rotation and Scaling</h2>
<p>In this section, we will learn how to position, rotate or scale the elements which we added so far.</p>
<p>We have created box, sphere, cylinder, knot, etc. Now, we will see how to position, scale and rotate the shapes.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No.</th>
<th style="text-align:center;">Element &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><a href="/babylonjs/babylonjs_basic_elements_position.htm">Position</a>
<p>With position change, the mesh will be changed from one position to another.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><a href="/babylonjs/babylonjs_basic_elements_rotation.htm">Rotation</a>
<p>With rotation, the mesh will be rotated around the mesh.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><a href="/babylonjs/babylonjs_basic_elements_scaling.htm">Scaling</a>
<p>The scaling of mesh can be done with respect to x, y or z axis.</p></td>
</tr>
</table>
<h2>Basic Element - Parenting</h2>
<p>With Parenting, we will create a parent-child relationship between the meshes and see how they behave. So whatever transformations you apply to the parent, the same will also be applied to the child. Let us now understand the same with the demo shown below.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
         
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            scene.activeCamera.attachControl(canvas);
         
            var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 100, 100), scene);

            var boxa = BABYLON.Mesh.CreateBox("BoxA", 1.0, scene);
            boxa.position = new BABYLON.Vector3(0,0.5,0);

            var boxb = BABYLON.Mesh.CreateBox("BoxB", 1.0, scene);
            boxb.position = new BABYLON.Vector3(3,0.5,0);		
            boxb.scaling = new BABYLON.Vector3(2,1,2);

            var boxc = BABYLON.Mesh.CreateBox("BoxC", 1.0, scene);
            boxc.parent = boxb;
            boxc.position.z = -3;
         
            var ground = BABYLON.Mesh.CreateGround("ground1", 10, 6, 2, scene);
            ground.position = new BABYLON.Vector3(0,0,0);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/basic_element_parenting.jpg" alt="Basic Element Parenting" />
<h3>Explanation</h3>
<p>We have created 3 boxes in the above mesh. In the demo, boxb scaling is applied and it is assigned as a parent to boxc which also scales since its parent boxb and the same is scaled. You can play around with the demo to see how the parent-child link works.</p>
<p>To make a mesh, you have to use the parent of another mesh &minus;</p>
<ul class="list">
<li><p><b>child.parent = parentmesh;</b></p></li>
</ul>
<h2>Basic Element - Environment</h2>
<p>Let us now discuss the scene environment in this section. We will talk about the <b>scene background color, ambientcolor, skyboxes, fog mode</b>, etc. on a scene.</p>
<p>We have seen the <b>scene background color is demos</b> which we have created so far.</p>
<h3>Scene background-color</h3>
<p>Let us now see how the scene background color works.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the scene background color &minus;</p>
<pre class="result notranslate">
scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5);
or
scene.clearColor = BABYLON.Color3.Blue();
</pre>
<p>The above property will change the background color of the scene.</p>
<h3>Scene Ambient color</h3>
<p>Let us now see how the scene ambient color works.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the scene ambient color &minus;</p>
<pre class="result notranslate">
scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
</pre>
<p>AmbientColor is used along with the <b>StandardMaterial</b> ambient color and texture. If there is no ambientColor for the scene the <b>StandardMaterial.ambientColor</b> and <b>StandardMaterial.ambientTexture</b> has no effect. The StandardMaterial ambientColor/ambientTexture will become active once the ambientColor for scene is applied. By default, scene is given <b>scene.ambientColor</b> and set to <b>Color3</b> (0, 0, 0), which means no ambientColor.</p>
<h3>Scene Fog mode</h3>
<p>We will now understand how the Scene Fog Mode works.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the Scene Fog Mode.</p>
<pre class="result notranslate">
scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
</pre>
<p>The following list of the available fog modes &minus;</p>
<ul class="list">
<li><p><b>BABYLON.Scene.FOGMODE_NONE</b> &minus; default one, fog is deactivated.</p></li>
<li><p><b>BABYLON.Scene.FOGMODE_EXP</b> &minus; the fog density follows an exponential function.</p></li>
<li><p><b>BABYLON.Scene.FOGMODE_EXP2</b> &minus; same as above but faster.</p></li>
<li><p><b>BABYLON.Scene.FOGMODE_LINEAR</b> &minus; the fog density follows a linear function.</p></li>
</ul>
<p>If the fog mode EXP or EXP2 is defined, then you can define the density on it as follows &minus;</p>
<pre class="result notranslate">
scene.fogDensity = 0.01;
</pre>
<p>If the fog mode is LINEAR, then you can define where the fog starts and ends as follows &minus;</p>
<pre class="result notranslate">
scene.fogStart = 20.0;
scene.fogEnd = 60.0;
</pre>
<p>To give color to the fog, execute the following code &minus;</p>
<pre class="result notranslate">
scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
</pre>
<h3>Skybox</h3>
<p>Skybox is a way of creating background in games which makes the scene looks realistic. It is more of a wrapper around your screen which covers with the texture being used for the material. Choose your images properly to make it look realistic for the scene that you want to create. To create skybox, you have to create a box and apply material to it. We will discuss the different material in detail in a subsequent chapter.</p> 
<p>Now, we will see how to create a skybox using box and material.</p>
<pre class="result notranslate">
var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
</pre>
<p>We will create a box of size 100 so that it covers the entire scene. We will start by giving material to the box which is done as follows &minus;</p>
<pre class="result notranslate">
var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
</pre>
<p>To this material, we will assign the properties.</p>
<pre class="result notranslate">
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("images/cubetexture/skybox", scene);
</pre>
<p>We have to use reflection texture which is basically used to create a mirror like material. The reflection texture property uses CubeTexture which takes image as an input. Since the cube has 6 faces, the image required for skybox has to be 6, i.e., internally it has to be stored as skybox_nx, skybox_ny, skybox_nz, skybox_px, skybox_py, skybox_pz. The images used for skybox are pasted below; they are faces of the cube on all six sides. When you apply a texture to the shape, it gives the details of the image used and makes the scene look realistic. We made use of the co-ordinates mode as SKYBOX_MODE as shown below &minus;</p>
<pre class="result notranslate">
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
</pre>
<p>There are other properties used for material like backfaceCulling, diffuseColor, specularColor, disableLighting, etc. The properties are explained in detail in the material section.</p>
<p>In the demo, we will show an environment scene created using skybox, a sphere rotating in the scene and a plane moving around. Fog is applied to the scene, which you will notice when you rotate.</p>
<h3>Demo Showing Environment Scene</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt; Babylon.JS : Demo&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas { width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            var light = new BABYLON.PointLight("Omni", 
            new BABYLON.Vector3(10, 50, 50), scene);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 0.4, 1.2, 20, new BABYLON.Vector3(-10, 0, 0), scene);
            camera.attachControl(canvas, true);

            var material1 = new BABYLON.StandardMaterial("mat1", scene);
            material1.diffuseTexture = new BABYLON.Texture("images/tsphere.jpg", scene);

            var sphere = BABYLON.Mesh.CreateSphere("red", 32, 2, scene);
            sphere.setPivotMatrix(BABYLON.Matrix.Translation(2, 0, 0));
            sphere.material = material1;		

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
            scene.fogDensity = 0.01;

            //skybox		
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
            
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("images/cubetexture/skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            
            skyboxMaterial.disableLighting = true;
            skybox.material = skyboxMaterial;


            var spriteManagerPlayer = new BABYLON.SpriteManager("playerManager", "images/plane.png", 8, 1000, scene);
            
            var plane = new BABYLON.Sprite("plane", spriteManagerPlayer);
            plane.position.x = -2;
            plane.position.y = 2;	
            plane.position.z = 0;	


            var alpha = 0;
            var x = 2;
            var y = 0;
            scene.registerBeforeRender(function () {
               scene.fogDensity = Math.cos(alpha) / 10;
               alpha += 0.02;
               sphere.rotation.y += 0.01;
               y += 0.05; 
               if (x &gt; 50) {
                  x = -2;
               }
               plane.position.x = -x;
               x += 0.02; 
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/basic_element_skybox_mode.jpg" alt="Basic Element Skybox Mode" />
<h3>Explanation</h3> 
<p>In the above example, we used the following code for fog &minus;</p>
<pre class="prettyprint notranslate">
scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
scene.fogDensity = 0.01;
</pre>
<ul class="list">
<li><p><b>scene.fogMode = BABYLON.Scene.FOGMODE_EXP</b> &minus; Here, the fog density follows an exponential function.</p></li>
<li><p><b>scene.registerBeforeRender</b> = With this, the fog density changes as follows &minus;</p></li>
</ul>
<pre class="prettyprint notranslate">
var alpha = 0;
scene.registerBeforeRender(function () {
   scene.fogDensity = Math.cos(alpha) / 10;
   alpha += 0.02;
});
</pre>
<p>The value of alpha keeps incrementing by 0.02 as it goes in a loop as in the above function.</p>
<p>Here, we have added a plane sprite image and changed it’s position with the <b>scene.registerBeforeRender</b> function as follows &minus;</p>
<pre class="prettyprint notranslate">
var alpha = 0;
var x = 2;
var y = 0;
scene.registerBeforeRender(function () {
   scene.fogDensity = Math.cos(alpha) / 10;
   alpha += 0.02;
   sphere.rotation.y += 0.01;
   y += 0.05; 
   if (x &gt; 50) {
      x = -2;
   }
   plane.position.x = -x;
   x += 0.02; 
});
return scene;
};s
</pre>
<p>We will change the x axis of the plane and reset it when it reaches more than 50.</p>
<p>Also, the sphere is rotated along the y axis. This is shown in the above example.The value is changed using sphere.rotation.y.</p>
<p>The texture used for sphere is &minus; <b>images/tshphere.jpg</b>. The images are stored in images/ folder locally and  also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<img src="/babylonjs/images/basic_element_tshphere.jpg" alt="Basic Element Tshphere" />
<p>We need six images for a cube. The images are stored locally in images/cubetexture/ folder. You can download any image of your choice, but when you save it save them as nameoftheimage_nx, nameoftheimage_ny, nameoftheimage_nz,nameoftheimage_px, nameoftheimage_py, nameoftheimage_pz. Please note the images chosen should be in a sequence  so that the background looks realistic like the one shown for skybox.</p>
<p>The images used for making a skybox are as follows &minus; <b>images/cubetexture/skybox</b></p>
<p><b>skybox_nx</b></p>
<img src="/babylonjs/images/basic_element_skybox_nx.jpg" alt="Basic Element Skybox-nx" />
<p><b>skybox_ny</b></p>
<img src="/babylonjs/images/basic_element_skybox_ny.jpg" alt="Basic Element Skybox-nx" />
<p><b>skybox_nz</b></p>
<img src="/babylonjs/images/basic_element_skybox_nz.jpg" alt="Basic Element Skybox-nx" />
<p><b>skybox_px</b></p>
<img src="/babylonjs/images/basic_element_skybox_px.jpg" alt="Basic Element Skybox-nx" />
<p><b>skybox_py</b></p>
<img src="/babylonjs/images/basic_element_skybox_py.jpg" alt="Basic Element Skybox-nx" />
<p><b>skybox_pz</b></p>
<img src="/babylonjs/images/basic_element_skybox_pz.jpg" alt="Basic Element Skybox-nx" />
<h1>BabylonJS - Materials</h1>
<p>Materials are like clothes for the objects. You can add color, texture and wrap your meshes with it. You can use the same material to cover many meshes. Meshes can be the scene which we just saw in the example in the previous for chapter - the plane passing through the sky.</p>
<p>In this chapter, we will learn how to add color, texture, reflection for the meshes in this chapter.</p>
<p>We will add material to the already created scene. We will progress by adding material to all the shapes we created.</p>
<p>Let us consider a few examples to see how the addition of material works.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var materialforshapes = new BABYLON.StandardMaterial("texture1", scene);
</pre>
<p>The above material will not change anything since it is the default one. We will use the available properties to make the objects look more appealing.</p>
<p>The available properties are as follows &minus;</p>
<ul class="list">
<li><p><a href="/babylonjs/babylonjs_transparency.htm">Transparency</a></p></li>
<li><p><a href="/babylonjs/babylonjs_diffuse.htm">Diffuse</a></p></li>
<li><p><a href="/babylonjs/babylonjs_emissive.htm">Emissive</a></p></li>
<li><p><a href="/babylonjs/babylonjs_ambient.htm">Ambient</a></p></li>
<li><p><a href="/babylonjs/babylonjs_specular.htm">Specular</a></p></li>
<li><p><a href="/babylonjs/babylonjs_backface_culling.htm">Back-Face Culling</a></p></li>
<li><p><a href="/babylonjs/babylonjs_wireframe.htm">WireFrame</a></p></li>
</ul>
<p>Take a look how these properties applied on the material changes the look and feel of the mesh.</p>
<h2>Basic Material Property - FresnelParameters</h2>
<p>Fresnel is the new thing added by BabylonJS on <b>standardmaterial</b>. It allows to change the color applied on the shapes. You can get glass like reflection by using the simple Fresnel. The Fresnel will let you have more reflection on edges and not all on the center.</p>
<h3>Following properties are available for Fresnel</h3>
<pre class="result notranslate">
StandardMaterial.diffuseFresnelParameters
StandardMaterial.opacityFresnelParameters
StandardMaterial.reflectionFresnelParameters
StandardMaterial.emissiveFresnelParameters
StandardMaterial.refractionFresnelParameters
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 10, BABYLON.Vector3.Zero(), scene);

            camera.setPosition(new BABYLON.Vector3(0, 5, -10));

            camera.attachControl(canvas);
            camera.upperBetaLimit = Math.PI / 2;
            camera.lowerRadiusLimit = 4;

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            var knot = BABYLON.Mesh.CreateTorusKnot("knot", 1, 0.4, 128, 64, 2, 3, scene);	
            var yellowSphere = BABYLON.Mesh.CreateSphere("yellowSphere", 16, 1.5, scene);
            yellowSphere.setPivotMatrix(BABYLON.Matrix.Translation(3, 0, 0));
            var yellowMaterial = new BABYLON.StandardMaterial("yellowMaterial", scene);
            yellowMaterial.diffuseColor = BABYLON.Color3.Yellow();
            yellowSphere.material = yellowMaterial;    

            // Ground
            var ground = BABYLON.Mesh.CreateBox("Mirror", 1.0, scene);
            ground.scaling = new BABYLON.Vector3(100.0, 0.01, 100.0);
            ground.material = new BABYLON.StandardMaterial("ground", scene);
            ground.material.diffuseTexture = new BABYLON.Texture("images/rainbow.png", scene);
            ground.material.diffuseTexture.uScale = 10;
            ground.material.diffuseTexture.vScale = 10;
            ground.position = new BABYLON.Vector3(0, -2, 0);

            // Main material	
            var mainMaterial = new BABYLON.StandardMaterial("main", scene);
            knot.material = mainMaterial;

            var probe = new BABYLON.ReflectionProbe("main", 512, scene);
            probe.renderList.push(yellowSphere);
            probe.renderList.push(ground);
            mainMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0.5);
            mainMaterial.refractionTexture = probe.cubeTexture;
            mainMaterial.refractionFresnel&lt;h3&gt;Parameters&lt;/h3&gt; = new BABYLON.Fresnel&lt;h3&gt;Parameters&lt;/h3&gt;();
            mainMaterial.refractionFresnel&lt;h3&gt;Parameters&lt;/h3&gt;.bias = 0.5;
            mainMaterial.refractionFresnel&lt;h3&gt;Parameters&lt;/h3&gt;.power = 16;
            mainMaterial.refractionFresnel&lt;h3&gt;Parameters&lt;/h3&gt;.leftColor = BABYLON.Color3.Black();
            mainMaterial.refractionFresnel&lt;h3&gt;Parameters&lt;/h3&gt;.rightColor = BABYLON.Color3.White();
            mainMaterial.indexOfRefraction = 1.05;

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
            scene.fogColor = scene.clearColor;
            scene.fogStart = 20.0;
            scene.fogEnd = 50.0;

            // Animations
            scene.registerBeforeRender(function () {
               yellowSphere.rotation.y += 0.01;
               //  greenSphere.rotation.y += 0.01;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/basic_material_property_fresnelparameters.jpg" alt="Basic Material Property - FresnelParameters" />
<h3>Explanation</h3> 
<p>Following code applies the Fresnel effect. The colors left and right are applied to the edges of the meshes.</p>
<pre class="result notranslate">
mainMaterial.refractionFresnelParameters = new BABYLON.FresnelParameters();
mainMaterial.refractionFresnelParameters.bias = 0.5;
mainMaterial.refractionFresnelParameters.power = 16;
mainMaterial.refractionFresnelParameters.leftColor = BABYLON.Color3.Black();
mainMaterial.refractionFresnelParameters.rightColor = BABYLON.Color3.White();
</pre>
<p>Bias and power property control the Fresnel effect on the surface.</p>
<p>In this demo, we have used an image called rainbow.png. The images are stored in images/ folder locally. You can download any image of your choice and use in the demo link.</p>
<h1>BabylonJS - Animations</h1>
<p>Animation makes a scene more interactive and also makes it impressive giving realistic look to it. Let us now understand animation in detail. We will apply animation on shapes to move it from one position to another. To use animation, you need to create an object on animation with the required parameters.</p>
<p>Let us now see the syntax for the same &minus;</p>
<pre class="result notranslate">
var animationBox = new BABYLON.Animation(
   "myAnimation", 
   "scaling.x", 
   30, 
   BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
   BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to Animations with BabylonJS &minus;</p>
<ul class="list">
<li><p>Name of the animation.</p></li>
<li><p>Property of the shape – for example, scaling, changing position, etc. Scaling is what is shown in the syntax; here, it will scale the box along the x-axis.</p></li>
<li><p>Frames per second requested: highest FPS possible in this animation.</p></li>
<li><p>Here you decide and enter what kind of value will be modified: is it a float (e.g. a translation), a vector (e.g. a direction), or a quaternion.</p></li>
<li><p>Exact values are &minus;</p></li>
<ul class="list">
<li><p>BABYLON.Animation.ANIMATIONTYPE_FLOAT</p></li>
<li><p>BABYLON.Animation.ANIMATIONTYPE_VECTOR2</p></li>
<li><p>BABYLON.Animation.ANIMATIONTYPE_VECTOR3</p></li>
<li><p>BABYLON.Animation.ANIMATIONTYPE_QUATERNION</p></li>
<li><p>BABYLON.Animation.ANIMATIONTYPE_COLOR3</p></li>
</ul>
<li><p>Behaviour for animation - to stop or to start the animation again.</p></li>
<li><p>Use previous values and increment it &minus;</p></li>
<ul class="list">
<li><p>BABYLON.Animation.ANIMATIONLOOPMODE_RELATIVE</p></li>
</ul>
<li><p>Restart from initial value &minus;</p></li>
<ul class="list">
<li><p>BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE</p></li>
</ul>
<li><p>Keep their final value</p></li>
<ul class="list">
<li><p>BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT</p></li>
</ul>
</ul>
<p>Let us now create the animation object &minus;</p>
<pre class="result notranslate">
var animationBox = new BABYLON.Animation(
   "myAnimation", 
   "scaling.x", 
   30, 
   BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
   BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
);
</pre>
<h3>Demo for Animation</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;	
            
            var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
            pl.diffuse = new BABYLON.Color3(1, 1, 1);
            pl.specular = new BABYLON.Color3(1, 1, 1);
            pl.intensity = 0.8;
            
            var box = BABYLON.Mesh.CreateBox("box", '3', scene);
            box.position = new BABYLON.Vector3(-10,0,0);

            var box1 = BABYLON.Mesh.CreateBox("box1", '3', scene);
            box1.position = new BABYLON.Vector3(0,0,0);

            var animationBox = new BABYLON.Animation("myAnimation", "scaling.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            var animationBox1 = new BABYLON.Animation("myAnimation1", "scaling.z", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            // An array with all animation keys
            var keys = []; 

            //At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 1
            });

            //At the animation key 20, the value of scaling is "0.2"
            keys.push({
               frame: 20,
               value: 0.2
            });

            keys.push({
               frame: 60,
               value: 0.4
            });

            //At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 1
            });
            
            animationBox.setKeys(keys);
            box.animations = [];
            box.animations.push(animationBox);			
            scene.beginAnimation(box, 0, 100, true); 

            // An array with all animation keys
            var keys = []; 

            //At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 1
            });

            //At the animation key 20, the value of scaling is "0.2"
            keys.push({
               frame: 60,
               value: 0.2
            });

            //At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 1
            });
            animationBox1.setKeys(keys);
            box1.animations = [];
            box1.animations.push(animationBox1);			
            scene.beginAnimation(box1, 0, 100, true); 
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/animation_demo.jpg" alt="Animation Demo" />
<p></p>
<pre class="prettyprint notranslate">
// An array with all animation keys
var keys = []; 

//At the animation key 0, the value of scaling is "1"
keys.push({
   frame: 0,
   value: 1
});

//At the animation key 20, the value of scaling is "0.2"
keys.push({
   frame: 20,
   value: 0.2
});

//At the animation key 100, the value of scaling is "1"
keys.push({
   frame: 100,
   value: 1
});

animationBox.setKeys(keys);

box.animations = [];

box.animations.push(animationBox);

scene.beginAnimation(box, 0, 100, true); //defines the start and the end on the target shape box.
</pre>
<p>Following are the other functions available on animation object &minus;</p>
<ul class="list">
<li>pause()</li>
<li>restart()</li>
<li>stop()</li>
<li>reset()</li>
</ul>
<p>We can store the <b>beginAnimation</b> reference in a variable and use the reference to stop, pause or reset animation.</p>
<pre class="result notranslate">
var newAnimation = scene.beginAnimation(box1, 0, 100, true);
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
newAnimation.pause();
</pre>
<p>There are functions available on animation object to control the keyframes.</p>
<pre class="prettyprint notranslate">
BABYLON.Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {
   return startValue + (endValue - startValue) * gradient;
};

BABYLON.Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {
   return BABYLON.Quaternion.Slerp(startValue, endValue, gradient);
};

BABYLON.Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {
   return BABYLON.Vector3.Lerp(startValue, endValue, gradient);
};
</pre>
<p>Here is the list of functions that you can change &minus;</p>
<ul class="list">
<li>floatInterpolateFunction</li>
<li>quaternionInterpolateFunction</li>
<li>quaternionInterpolateFunctionWithTangents</li>
<li>vector3InterpolateFunction</li>
<li>vector3InterpolateFunctionWithTangents</li>
<li>vector2InterpolateFunction</li>
<li>vector2InterpolateFunctionWithTangents</li>
<li>sizeInterpolateFunction</li>
<li>color3InterpolateFunction</li>
<li>matrixInterpolateFunction</li>
</ul>
<p>To create a quick animation, there is a function available which can be used directly.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
Animation.CreateAndStartAnimation = function(name, mesh, tartgetProperty, framePerSecond, totalFrame, from, to, loopMode);
</pre>
<p>Here you can use only 2 keyframes - <b>start</b> and <b>end</b>.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;	
            
            var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
            pl.diffuse = new BABYLON.Color3(1, 1, 1);
            pl.specular = new BABYLON.Color3(1, 1, 1);
            pl.intensity = 0.8;
            
            var box = BABYLON.Mesh.CreateBox("box", '3', scene);
            box.position = new BABYLON.Vector3(0,0,0);
            BABYLON.Animation.CreateAndStartAnimation('boxscale', box, 'scaling.x', 30, 120, 1.0, 1.5);  
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/animation_demo_image.jpg" alt="Animation Demo Image" />
<h3>Animation Blending</h3>
<p>You can achieve animation blending with the help of enableBlending = true;</p>
<p>This blended animation will change from the current object state.</p>
<h3>Easing Functions</h3>
<p>To make the animation more impressive, there are some easing functions which we have already used with css earlier.</p>
<p>Following is a list of easing functions &minus;</p>
<ul class="list">
<li><p>BABYLON.CircleEase ()</p></li>
<li><p>BABYLON.BackEase (amplitude)</p></li>
<li><p>BABYLON.BounceEase (bounces, bounciness)</p></li>
<li><p>BABYLON.CubicEase ()</p></li>
<li><p>BABYLON.ElasticEase (oscillations, springiness)</p></li>
<li><p>BABYLON.ExponentialEase (exponent)</p></li>
<li><p>BABYLON.PowerEase (power)</p></li>
<li><p>BABYLON.QuadraticEase ()</p></li>
<li><p>BABYLON.QuarticEase ()</p></li>
<li><p>BABYLON.QuinticEase ()</p></li>
<li><p>BABYLON.SineEase ()</p></li>
</ul>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;	
            
            var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
            pl.diffuse = new BABYLON.Color3(1, 1, 1);
            pl.specular = new BABYLON.Color3(1, 1, 1);
            pl.intensity = 0.8;

            var box1 = BABYLON.Mesh.CreateTorus("torus", 5, 1, 10, scene, false);
            box1.position = new BABYLON.Vector3(0,0,0);

            var animationBox1 = new BABYLON.Animation("myAnimation1", "scaling.z", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            // An array with all animation keys
            var keys = []; 

            //At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 1
            });

            //At the animation key 20, the value of scaling is "0.2"
            keys.push({
               frame: 60,
               value: 0.2
            });

            //At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 1
            });
            
            animationBox1.setKeys(keys);
            box1.animations = [];
            // box1.animations.push(animationBox1);		

            var easingFunction = new BABYLON.QuarticEase();
            easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

            animationBox1.setEasingFunction(easingFunction);
            box1.animations.push(animationBox1);
            scene.beginAnimation(box1, 0, 100, true); 
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/animation_blending.jpg" alt="Animation Blending" />
<h3>Animation Event</h3>
<p>You can carry out anything necessary on animation event. If you want to change anything when the frame is changed or when the animation is complete, it can be achieved by adding events to the animation.</p>
<pre class="prettyprint notranslate">
var event1 = new BABYLON.AnimationEvent(50, function() { console.log("Yeah!"); }, true);
// You will get hte console.log when the frame is changed to 50 using animation.

animation.addEvent(event1); //attaching event to the animation.
</pre>
<h2>BabylonJS - Sprites</h2>
<p>What does sprites refer to in computer graphics? It is basically a 2-dimensional bitmap that is integrated into a larger scene. When multiple smaller images are combined into a single bitmap to save memory, the resulting image is called a sprite sheet. Let us get started with sprites and how to use them.</p>
<p>The first step to start working with sprites is to create a sprite manager.</p>
<pre class="prettyprint notranslate">
var spriteManagerTrees = new BABYLON.SpriteManager("treesManagr", "Assets/Palm-arecaceae.png", 2000, 800, scene);
</pre>
<p>Consider the following parameters to create sprite manager &minus;</p>
<ul class="list">
<li><p><b>Name</b> &minus; The name of this manager.</p></li>
<li><p><b>URL</b> &minus; The image url to be used.</p></li>
<li><p><b>Capacity of manager</b> &minus; The maximum number of instances in this manager.For example, the above insteance will create 2000 trees.</p></li>
<li><p><b>Cell size</b> &minus; The size taken by the image.</p></li>
<li><p><b>Scene</b> &minus; The scene to which the manager will be added.</p></li>
</ul>
<pre class="prettyprint notranslate">
var spriteManagerPlayer = new BABYLON.SpriteManager("playerManagr","Assets/Player.png", 2, 64, scene);
</pre>
<p>Take a look at the above object.We have given a player image and are now creating 2 instances of it. The size of the image is 64. Each image of a sprite must be contained in a64 pixel square, no more no less.</p>
<p>Let us now create instance of the same linked to the sprite manager.</p>
<pre class="result notranslate">
var player = new BABYLON.Sprite("player", spriteManagerPlayer);
</pre>
<p>You can play around with this player object just like any other shapes or meshes. You can assign position, size, angle, etc.</p>
<pre class="result notranslate">
player.size = 0.3;
player.angle = Math.PI/4;
player.invertU = -1;
player.width = 0.3;
player.height = 0.4;
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            //scene.clearColor = new BABYLON.Color3(0, 1, 0);	
            // Create camera and light
            var light = new BABYLON.PointLight("Point", new BABYLON.Vector3(5, 10, 5), scene);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 8, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var spriteManagerTrees = new BABYLON.SpriteManager("trees", "images/tree.png", 1000, 400, scene);	

            for (var i = 0; i &lt; 1000; i++) {
               var tree = new BABYLON.Sprite("tree", spriteManagerTrees);
               tree.position.x = Math.random() * 100 - 50;
               tree.position.z = Math.random() * 100 - 50;
               tree.isPickable = true;

               //Some "dead" trees
               if (Math.round(Math.random() * 5) === 0) {
                  tree.angle = Math.PI * 90 / 180;
                  tree.position.y = -0.3;
               }
            }

            var spriteManagerTrees1 = new BABYLON.SpriteManager("trees1", "images/tree1.png", 1000,400, scene);	

            for (var i = 0; i &lt; 1000; i++) {
               var tree1 = new BABYLON.Sprite("tree1", spriteManagerTrees1);       
               if (i %2 == 0) {
               tree1.position.x = Math.random() * 100 - 50;			
               } else {
                  tree1.position.z = Math.random() * 100 - 50;
               }
               tree1.isPickable = true;
            }

            spriteManagerTrees.isPickable = true;
            spriteManagerTrees1.isPickable = true;

            var spriteManagerPlayer = new BABYLON.SpriteManager("playerManager", "images/bird.png", 2, 200, scene);
            
            var player = new BABYLON.Sprite("player", spriteManagerPlayer);
            player.position.x = 2;
            player.position.y = 2;	
            player.position.z = 0;	


            var spriteManagerPlayer1 = new BABYLON.SpriteManager("playerManager1", "images/bird.png", 2, 200, scene);
            
            var player1 = new BABYLON.Sprite("player", spriteManagerPlayer1);
            player1.position.x = 1;
            player1.position.y = 2;	
            player1.position.z = 0;	

            var spriteManagerPlayer2 = new BABYLON.SpriteManager("playerManager2", "images/bird.png", 2, 200, scene);
            
            var player2 = new BABYLON.Sprite("player", spriteManagerPlayer2);
            player2.position.x = 0;
            player2.position.y = 1;	
            player2.position.z = 0;	

            scene.onPointerDown = function (evt) {
               var pickResult = scene.pickSprite(this.pointerX, this.pointerY);
               if (pickResult.hit) {
                  pickResult.pickedSprite.angle += 1;
               }
            };
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/babylonjs_sprites.jpg" alt="BabylonJS Sprites" />
<p>In this demo, we have used an image called tree.png, tree1.png to show trees, bird.png to show bird in the scene. These images are stored in images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<p>The images used for Tree are shown below.</p>
<p><b>images/tree.png</b></p>
<img src="/babylonjs/images/tree.jpg" alt="BabylonJS Sprites" />
<p><b>images/tree1.png</b></p>
<img src="/babylonjs/images/tree1.jpg" alt="BabylonJS Sprites" />
<p><b>images/bird.png</b></p>
<img src="/babylonjs/images/bird.jpg" alt="BabylonJS Sprites" />
<p>Let us now see one more demo with sprites-balloons.</p>
<h3>Demo with sprites-balloons</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height:100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var light = new BABYLON.PointLight("Point", new BABYLON.Vector3(5, 10, 5), scene);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", -3.4, 1.0, 82, new BABYLON.Vector3(0, -15, 0), scene);
            camera.setPosition(new BABYLON.Vector3(30, 0,100));
            camera.attachControl(canvas, true);
            
            var spriteManagerTrees = new BABYLON.SpriteManager("trees", "images/balloon.png", 50, 450, scene);	

            var treearray = [];
            for (var i = 0; i &lt; 50; i++) {
               var tree = new BABYLON.Sprite("tree", spriteManagerTrees);
               tree.position.x = Math.random() * 100 - 10;
               tree.position.z = Math.random() * 100 - 10;
               tree.position.y = -35;
               tree.isPickable = true;       
               treearray.push(tree);
            }

            spriteManagerTrees.isPickable = true;
            scene.onPointerDown = function (evt) {
               var pickResult = scene.pickSprite(this.pointerX, this.pointerY);
               if (pickResult.hit) {
                  pickResult.pickedSprite.position.y = -3000;			
               }
            };
            
            k = -35;
            var animate = function() {
               if (k &gt; 3) return;
               k += 0.05;
               for (var i = 0; i &lt; treearray.length; i++) {
                  treearray[i].position.y = k;
               }
            };
            scene.registerBeforeRender(animate);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/sprites_balloons.jpg" alt="Sprites Balloons" />
<p>In this demo, we have used image called ballon.png. The images are stored in images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<p><b>images/balloon.png</b></p>
<img src="/babylonjs/images/balloon.jpg" alt="Balloon" />
<p>Balloons will rise in the sky and once they stop, you can click on them and they will disappear. This is done using the pickSprite function which gives details when clicked on the created sprite.</p>
<p>The onPointerDown function is called when the mouse action takes place and the position of sprite is changed.</p>
<pre class="prettyprint notranslate">
var animate = function() {
   if (k &gt; 3) return;
   k += 0.05;
   for (var i = 0; i &lt; treearray.length; i++) {
      treearray[i].position.y = k;
   }
};
scene.registerBeforeRender(animate);
</pre>
<p>The function animate is called in registerBeforeRender, which takes care of moving the ballons from  initial -35 to +3. It is moved slowly by incrementing it by .05.</p>
<h2>BabylonJS - Particles</h2>
<p>A particle system is a technique in computer graphics which makes use of a large number of very small sprites, 3D models, or other graphic objects to simulate certain kinds of "fuzzy" phenomena, which are otherwise very hard to reproduce with conventional rendering techniques.</p>
<p>To create particle system, you have to call the class as follows &minus;</p>
<pre class="result notranslate">
var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);//2000 refers to the total number of particles to be produced.
</pre>
<p>The following properties need to be considered for the particle system &minus;</p>
<pre class="prettyprint notranslate">
particleSystem.particleTexture = new BABYLON.Texture("Flare.png", scene);
particleSystem.textureMask = new BABYLON.Color4(0.1, 0.8, 0.8, 1.0);
particleSystem.emitter = fountain
particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);
</pre>
<p>The emitter property takes the mesh from which the particle has to be emitted. The <b>color1</b> and <b>color2</b> are the colors for the particles.</p>
<p><b>ColorDead</b> is the color applied to the particle just before it disappears from the scene hence called colorDead.</p>
<pre class="prettyprint notranslate">
particleSystem.minSize = 0.1;
particleSystem.maxSize = 0.5;
particleSystem.minLifeTime = 0.3;
particleSystem.maxLifeTime = 1.5;
</pre>
<p>MinSize and maxSize is the size given to the particles. MinlifeTime and maxLifeTime is the lifetime given to the particles.</p>
<pre class="prettyprint notranslate">
particleSystem.emitRate = 1500;
</pre>
<p>The emitRate is the rate at which particles will be emitted.</p>
<p>We have used torus in the demo shown below. We have used the particle system and its properties to get all particles around the torus.</p>
<h3>Demo 1</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            // Setup environment
            
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 2, 8), scene);
            
            var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 20, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var fountain = BABYLON.Mesh.CreateTorus("torus", 2, 1, 8, scene, false);
            
            var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
            particleSystem.particleTexture = new BABYLON.Texture("images/dot.jpg", scene);

            particleSystem.textureMask = new BABYLON.Color4(0.1, 0.8, 0.8, 1.0);
            particleSystem.emitter = fountain;


            particleSystem.minEmitBox = new BABYLON.Vector3(-1, 0, 0); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(1, 0, 0); // To...

            particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

            particleSystem.minSize = 0.1;
            particleSystem.maxSize = 0.5;

            particleSystem.minLifeTime = 0.3;
            particleSystem.maxLifeTime = 1.5;

            particleSystem.emitRate = 1500;

            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

            particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

            particleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);
            particleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);


            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = Math.PI;

            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 3;
            particleSystem.updateSpeed = 0.005;

            particleSystem.start();
            var keys = [];
            var animation = new BABYLON.Animation("animation", "rotation.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                                   BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            
            // At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 0
            });

            // At the animation key 50, the value of scaling is "0.2"
            keys.push({
               frame: 50,
               value: Math.PI
            });

            // At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 0
            });

            // Launch animation
            animation.setKeys(keys);
            fountain.animations.push(animation);
            scene.beginAnimation(fountain, 0, 100, true);
            return scene;
         }
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });	
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;	
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/babylonjs_particles.jpg" alt="BabylonJS Particles" />
<p>In this demo, we have used image called dot.jpg. The images are stored in images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<p>Following is the imageused for particle texture: <b>images/dot.jpg</b></p>
<img src="/babylonjs/images/dot.jpg" alt="Dot" />
<h3>Demo 2</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Ball/Ground Demo&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(-100, 0,-100));
            camera.attachControl(canvas, true);
            
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            var pl = new BABYLON.PointLight("pl", new BABYLON.Vector3(0, 0, 0), scene);

            var gmat = new BABYLON.StandardMaterial("mat1", scene);
            gmat.alpha = 1.0;
            
            var ground =  BABYLON.Mesh.CreateGround("ground", 100, 100, 20, scene);
            ground.material = gmat;
            gmat.wireframe = true;

            var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
            particleSystem.particleTexture = new BABYLON.Texture("images/dot.jpg", scene);

            particleSystem.textureMask = new BABYLON.Color4(0.1, 0.8, 0.8, 1.0);
            particleSystem.emitter = ground;

            particleSystem.minEmitBox = new BABYLON.Vector3(-1, 0, 0); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(1, 0, 0); // To...

            particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

            particleSystem.minSize = 0.1;
            particleSystem.maxSize = 0.5;

            particleSystem.minLifeTime = 0.3;
            particleSystem.maxLifeTime = 1.5;

            particleSystem.emitRate = 1500;

            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

            particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

            particleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);
            particleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);

            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = Math.PI;

            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 3;
            particleSystem.updateSpeed = 0.005;

            particleSystem.start();


            var keys = [];
            var animation = new BABYLON.Animation("animation", "rotation.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                           BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            // At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 0
            });

            // At the animation key 50, the value of scaling is "0.2"
            keys.push({
               frame: 50,
               value: Math.PI
            });

            // At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 0
            });

            // Launch animation
            animation.setKeys(keys);
            ground.animations.push(animation);
            
            //scene.beginAnimation(ground, 0, 100, true);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/demo_particles.jpg" alt="Demo Particles" />
<h3>Demo with Animation</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Ball/Ground Demo&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(-100, 0, -100));
            camera.attachControl(canvas, true);
            
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            var pl = new BABYLON.PointLight("pl", new BABYLON.Vector3(0, 0, 0), scene);

            var gmat = new BABYLON.StandardMaterial("mat1", scene);
            gmat.alpha = 1.0;
            
            var ground =  BABYLON.Mesh.CreateGround("ground", 100, 100, 20, scene);
            ground.material = gmat;
            gmat.wireframe = true;

            var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
            particleSystem.particleTexture = new BABYLON.Texture("images/dot.jpg", scene);

            particleSystem.textureMask = new BABYLON.Color4(0.1, 0.8, 0.8, 1.0);
            particleSystem.emitter = ground;

            particleSystem.minEmitBox = new BABYLON.Vector3(-1, 0, 0); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(1, 0, 0); // To...

            particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

            particleSystem.minSize = 0.1;
            particleSystem.maxSize = 0.5;

            particleSystem.minLifeTime = 0.3;
            particleSystem.maxLifeTime = 1.5;

            particleSystem.emitRate = 1500;

            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

            particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);//gravity for the particle.

            particleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);
            particleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);
            
            //random direction for the particles on the scene
            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = Math.PI;
            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 3;
            particleSystem.updateSpeed = 0.005;

            particleSystem.start();

            var keys = [];
            var animation = new BABYLON.Animation("animation", "rotation.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                           BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            
            // At the animation key 0, the value of scaling is "1"
            keys.push({
               frame: 0,
               value: 0
            });

            // At the animation key 50, the value of scaling is "0.2"
            keys.push({
               frame: 50,
               value: Math.PI
            });

            // At the animation key 100, the value of scaling is "1"
            keys.push({
               frame: 100,
               value: 0
            });

            // Launch animation
            animation.setKeys(keys);
            ground.animations.push(animation);
            scene.beginAnimation(ground, 0, 100, true); 
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/particle_animation.jpg" alt="Particles Animation" />
<h3>Explanation</h3>
<p>The above demo shows a ground with wireframe material and the particle system is produced from the center.</p>
<h1>BabylonJS - Cameras</h1>
<p>BabylonJS has many cameras that can be used. At a time, only one camera will be active for a scene.</p>
<p>In this chapter, we will learn how to go about using cameras in BabylonJS.</p>
<h2>FreeCamera</h2>
<p>Let us now see how the FreeCamera works.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the FreeCamera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 1, -15), scene);
</pre>
<p>This is the position in which the camera is placed - new BABYLON.Vector3(0, 1, -15).</p>
<p>Changing the direction will change the direction. You can change the values and see how the camera behaves on the scene.</p>
<p>Following are the parameters used by the FreeCamera &minus;</p>
<ul class="list">
<li>Name</li>
<li>Position</li> 
<li>Scene</li>
</ul>
<h2>ArcRotateCamera</h2>
<p>This camera rotates around a given target pivot. It can be controlled with cursors and mouse, or with touch events. Parameters are name, alpha, beta, radius and target.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
</pre>
<p><b>ArcRotateCamera</b> points in the +x direction. To change the position of the camera, use the <b>setPosition</b> property.</p>
<pre class="result notranslate">
camera.setPosition(new BABYLON.Vector3(0, 0, -100));
</pre>
<p>The ArcRotateCamera is an excellent camera to animate. The following command will help you rotate the camera around the target &minus;</p>
<pre class="result notranslate">
scene.activeCamera.alpha += .01;
</pre>
<h2>TouchCamera</h2>
<p>Touch is a type of a'gesture'. It can be on a pad or screen, with finger(s), stylus, glove, feet, or laser pointer. Any movement that can be sensed... can be considered a gesture.</p>
<h3>Syntax</h3>
<p>Following is the syntax for TouchCamera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.TouchCamera("TouchCamera", new BABYLON.Vector3(0, 1, -15), scene);
</pre>
<h2>GamepadCamera</h2>
<p>This camera is specially designed to be used with gamepad.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the Gamepad Camera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.GamepadCamera("Camera", new BABYLON.Vector3(0, 15, -45), scene);
</pre>
<h2>DeviceOrientationCamera</h2>
<p>This camera is specially designed to react to device orientation events cases like when you tilt your device forward or backward, left or right, etc.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var camera = new BABYLON.DeviceOrientationCamera("DevOr_camera", new BABYLON.Vector3(0, 1, -15), scene);
</pre>
<h2>FollowCamera</h2>
<p>FollowCamera is designed to follow any scene item with a position. It can follow from rear, front or from any angle.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the FollowCamera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 15, -45), scene);
</pre>
<h2>VirtualJoysticksCamera</h2>
<p>This camera is designed to react to Virtual Joystick events. The Virtual Joysticks are on-screen 2D graphics that are used to control cameras or other scene items.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the VirtualJoysticksCamera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.VirtualJoysticksCamera("VJ_camera", new BABYLON.Vector3(0, 1, -15), scene);
</pre>
<h2>AnaglyphCamera</h2>
<p>The AnaglyphCamera is for use with red and cyan 3D glasses. It uses post-processing filtering techniques.</p>
<h3>AnaglyphArcRotateCamera</h3>
<p>Following is the syntax for the AnaglyphArcRotateCamera &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.AnaglyphArcRotateCamera("aar_cam", -Math.PI/2, Math.PI/4, 20, new BABYLON.Vector3.Zero(), 0.033, scene);
</pre>
<h3>AnaglyphFreeCamera</h3>
<p>Following is the syntax for the <b>AnaglyphFreeCamera</b> &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.AnaglyphFreeCamera("af_cam", new BABYLON.Vector3(0, 1, -15), 0.033, scene);
</pre>
<h2>VRDeviceOrientationFreeCamera</h2>
<p>The VRDeviceOrientationFreeCamera uses FreeCamera as its basis, so the properties and methods of FreeCamera are also found on our VRDeviceOrientationFreeCamera.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the <b>VRDeviceOrientationFreeCamera</b> &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.VRDeviceOrientationFreeCamera ("Camera", new BABYLON.Vector3 (-6.7, 1.2, -1.3), scene, 0);
</pre>
<h2>WebVRFreeCamera</h2>
<p>The WebVRFreeCamera uses FreeCamera as its basis, so the properties and methods of FreeCamera are also found on our WebVRFreeCamera.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the <b>WebVRFreeCamera</b> &minus;</p>
<pre class="result notranslate">
var camera = new BABYLON.WebVRFreeCamera("WVR", new BABYLON.Vector3(0, 1, -15), scene);
</pre>
<p>In most of the demos, you will see <b>attachControl</b> where the camera is attached to the canvas.</p>
<h3>Example</h3>
<pre class="result notranslate">
camera.attachControl(canvas, true);
</pre>
<h1>BabylonJS - Lights</h1>
<p>In this chapter, we will learn about the lights used for BabylonJS. We will start by taking a look at the different types of lights available with babylonjs.</p>
<p>Lights are meant to produce the diffuse and specular color received by each pixel. Later, it is used on material to get the final color of each pixel.</p>
<p>There are 4 types of lights available with babylonjs.</p>
<ul class="list">
<li>Point Light</li>
<li>Directional Light</li>
<li>Spot Light</li>
<li>Hemispheric Light</li>
</ul>
<h2>BabylonJS - Point Light</h2>
<p>A classic example of point light is the Sun, the rays of which are spread in all direction. Point light has a unique point in space from where it spreads the light in every direction. The color of light can be controlled using the specular and diffuse property.</p>
<h3>Syntax</h3>
<p>Following is the syntax for Point Light &minus;</p>
<pre class="result notranslate">
var light0 = new BABYLON.PointLight("Omni0", new BABYLON.Vector3(1, 10, 1), scene);
</pre>
<p>There are three different params for point light &minus;</p>
<ul class="list">
<li><p>The 1st param is the name of the light.</p></li>
<li><p>The 2nd param is the position where the point light is placed.</p></li>
<li><p>The 3rd param is the scene to which the light needs to be attached.</p></li>
</ul> 
<p>Following properties are used to add color on the object created above &minus;</p>
<pre class="result notranslate">
light0.diffuse = new BABYLON.Color3(1, 0, 0);
light0.specular = new BABYLON.Color3(1, 1, 1);
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -100));
            camera.attachControl(canvas, true);
            
            var pl = new BABYLON.PointLight("pl", new BABYLON.Vector3(1, 20, 1), scene);
            pl.diffuse = new BABYLON.Color3(0, 1, 0);
            pl.specular = new BABYLON.Color3(1, 0, 0);
            
            var ground = BABYLON.Mesh.CreateGround("ground", 150, 6, 2, scene);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/pointlight.jpg" alt="Pointlight" />
<h2>BabylonJS - The Directional Light</h2>
<p>In directional light, the light is defined by the direction and is emitted in every direction based on where you place it.</p>
<pre class="result notranslate">
var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(0, -1, 0), scene);
</pre>
<p>There are three different params for point light &minus;</p>
<ul class="list">
<li><p>The 1<sup>st</sup> param is the name of the light.</p></li>
<li><p>The 2<sup>nd</sup> param is the position. Right now, it isplaced with negative -1 in the Y axis.</p></li>
<li><p>The 3<sup>rd</sup> param is the scene to be attached.</p></li>
</ul>
<p>Here, you can add color with the specular and diffuse property.</p>
<pre class="result notranslate">
light0.diffuse = new BABYLON.Color3(0, 1, 0);
light0.specular = new BABYLON.Color3(1,0, 0);
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -100));
            camera.attachControl(canvas, true);
            
            var pl = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(0, -10, 0), scene);
            pl.diffuse = new BABYLON.Color3(0, 1, 0);
            pl.specular = new BABYLON.Color3(1, 0, 0);
            
            var ground = BABYLON.Mesh.CreateGround("ground", 150, 6, 2, scene);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/directional_light.jpg" alt="Directional Light" />
<h2>BabylonJS - The Spot Light</h2>
<p>Spot light is just like light falling in cone shape.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the Spot Light &minus;</p>
<pre class="result notranslate">
var light0 = new BABYLON.SpotLight("Spot0", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), 0.8, 2, scene);
</pre>
<p>There are five different params for point light &minus;</p>
<ul class="list">
<li>1<sup>st</sup> Param is the name of the light.</li>
<li>2<sup>nd</sup> param is the position.</li>
<li>3<sup>rd</sup> param is the direction.</li>
<li>4<sup>th</sup> param is the angle.</li>
<li>5<sup>th</sup> param is the exponent.</li>
</ul>
<p>These values define a cone of light starting from the position, emitting towards the direction. Specular and diffuse are used to control the color of the light.</p>
<pre class="result notranslate">
light0.diffuse = new BABYLON.Color3(1, 0, 0);
light0.specular = new BABYLON.Color3(1, 1, 1);
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -100));
            camera.attachControl(canvas, true);
            
            var light0 = new BABYLON.SpotLight("Spot0", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), 0.8, 2, scene);
            light0.diffuse = new BABYLON.Color3(0, 1, 0);
            light0.specular = new BABYLON.Color3(1, 0, 0);
            
            var ground = BABYLON.Mesh.CreateGround("ground", 80,80, 2, scene);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/spot_light.jpg" alt="Spot Light" />
<h2>BabylonJS - The Hemispheric Light</h2>
<p>A hemispheric light is more of getting the environment light. The direction of the light is towards the sky. 3 colors are given to the light; one for the sky, one for the ground and the last one for the specular.</p>
<h3>Syntax</h3>
<p>Following is the syntax for the Hemispheric Light &minus;</p>
<pre class="result notranslate">
var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
</pre>
<h3>For colors</h3>
<pre class="result notranslate">
light0.diffuse = new BABYLON.Color3(1, 0, 0);
light0.specular = new BABYLON.Color3(0, 1, 0);
light0.groundColor = new BABYLON.Color3(0, 0, 0);
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);
            
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(0, 0, -0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -100));
            camera.attachControl(canvas, true);
            
            var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
            light0.diffuse = new BABYLON.Color3(1, 0, 0);
            light0.specular = new BABYLON.Color3(0, 1, 0);
            light0.groundColor = new BABYLON.Color3(0, 0, 0);
            
            var ground = BABYLON.Mesh.CreateGround("ground", 100,100, 2, scene);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/hemispheric_light.jpg" alt="Hemispheric Light" />
<h1>BabylonJS - Parametric Shapes</h1>
<p>Parametric shapes refer to different shapes that can be achieved using the lines drawn with bends, twists, etc. It is a 2D form generated with mathematical equation like parabola, sine curve, cos curve, Bezier curve, etc. With the equation, we can find the coordinates (x, y) and draw the line for the same. We will see shapes like ribbon, lines, dashlines,tube, extrusion in this chapter. A free hand drawing of lines on the board can be achieved with the parametric shapes described below.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No.</th>
<th style="text-align:center;">Parametric Shape &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><a href="/babylonjs/babylonjs_parametric_shapes_ribbon.htm">Ribbon</a>
<p>Ribbon takes an array of paths as input and draws lines along those paths. It uses complex logic to get the co-ordinates. In the example given below, we have used Bezier curve equation to draw the ribbon. Bezier curves are mostly used in 3D games to model the smooth curves. The curve needs control points and the curve is drawn along the control points.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><a href="/babylonjs/babylonjs_parametric_shapes_line.htm">Line</a>
<p>Line is a basic element in 3D games. To draw a line, you need two points between which you can draw a line.</p> </td>
</tr>
<tr>
<td class="ts">3</td>
<td><a href="/babylonjs/babylonjs_parametric_shapes_tube.htm">Tube</a>
<p>Tube is a curved cylinder shape. It can give different parametric shapes based on the equation (maths function) applied to it to get the co-ordinates.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><a href="/babylonjs/babylonjs_parametric_shapes_extrusion.htm">Extrusion</a>
<p>Extrusion helps in transforming a 2D shape into a volumic shape.Suppose you want to create a star with 2D you will have x,y co-ordinates and z will be 0.Taking the 2D co-ordinates extrusion will convert the same to a 3D shape.So, the start of 2D with extrusion will turn out to be a 3D.You can try different 2D shapes and convert those into 3D.</p></td>
</tr>
</table>
<h1>BabylonJS - Mesh</h1>
<p>In this chapter, we will learn to create different shapes using the mesh builder. We have already learnt how to create shapes in one of our previous chapters.</p>
<p>The difference is that with meshbuilder gives you the flexibility to add color, images to the shapes.</p>
<h2>CreateBox using MeshBuilder</h2>
<p>Let us now see how to create box using MeshBuilder.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 0, 1);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
            pl.diffuse = new BABYLON.Color3(1, 1, 1);
            pl.specular = new BABYLON.Color3(1, 1, 1);
            pl.intensity = 0.8;

            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0, 1, 0);
            
            var texture = new BABYLON.Texture("images/cube.png", scene);
            mat.diffuseTexture = texture;

            var hSpriteNb =  3;  // 3 sprites per raw
            var vSpriteNb =  2;  // 2 sprite raws

            var faceUV = new Array(6);
            for (var i = 0; i &lt; 6; i++) {
               faceUV[i] = new BABYLON.Vector4(i/hSpriteNb, i/vSpriteNb, (i+1)/hSpriteNb, (i+1)/vSpriteNb);
            }

            var options = {
               width: 1.5,
               height: 1.5,
               depth: 1.5,
               faceUV: faceUV
            };

            var box = BABYLON.MeshBuilder.CreateBox("box", options, scene);
            box.material = mat;

            scene.registerBeforeRender(function() { 
               pl.position = camera.position;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/meshbuilder_cubebox.jpg" alt="MeshBuilder CubeBox" />
<p>For the above example, we have used a sprite image as shown below. It has horizontally 3 Colums and vertically 2 rows.</p>
<img src="/babylonjs/images/cube.jpg" alt="Cube" />
<p>In this demo, we have used an image called cube.png. The images are stored in images/ folder locally and are also pasted below for reference. Please note cube.png is a sprite image,  a sprite image is a collection of images. We wanted to show the image on a cube so wanted all the sides of the cube together. You can also download similar sprite images of your choice and use in the demo link.</p>
<p>The createBox builder gives you options for the sizes.</p>
<p>For example,</p>
<pre class="result notranslate">
var box = BABYLON.MeshBuilder.CreateBox("box", options, scene);
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
var hSpriteNb =  3;  // 3 sprites per raw ie colums horizontally as shown in the image

var vSpriteNb =  2;  // 2 sprite raws as shown in the image above.

var faceUV = new Array(6); // the cube has 6 sides so creating array for same.
for (var i = 0; i &lt; 6; i++) {
   faceUV[i] = new BABYLON.Vector4(i/hSpriteNb, i/vSpriteNb, (i+1)/hSpriteNb, (i+1)/vSpriteNb);
}

var options = {
   width: 1.5,
   height: 1.5,
   depth: 1.5,
   faceUV: faceUV
};
</pre>
<p>This is called applying textures to the meshbuilder using the createBox method.We have used the image <b>cube.png</b> which has horizontally 3 colums and vertically 2 rows.The cube or box has 6 sides.</p>
<p>To apply textures we are using the options parameter.For example,</p>
<pre class="result notranslate">
Var box = BABYLON.MeshBuilder.CreateBox ('box', options, scene);
</pre>
<p>We have defined an array called faceUV with size as 6 which are the sides of the cube. This array will always have Vector4 elements. Each Vector4(x, y, z, w) will be defined as follows &minus;</p>
<ul class="list">
<li>x = Ubottom</li>
<li>y = Vbottom</li>
<li>z = Utop</li>
<li>w = Vtop</li>
</ul>
<p>The vectorsare in the range [0, 1]. Ubottom and Vbottom are the 2D coordinates of the bottom left point of where the texture crop starts. Utop, Vtop are the top right points where the texture crop ends.</p>
<pre class="prettyprint notranslate">
var hSpriteNb =  3;  // 3 sprites per raw
var vSpriteNb =  2;  // 2 sprite raws

var faceUV = new Array(6);
for (var i = 0; i &lt; 6; i++) {
   faceUV[i] = new BABYLON.Vector4(i/hSpriteNb, i/vSpriteNb, (i+1)/hSpriteNb, (i+1)/vSpriteNb);
}
</pre>
<p>Suppose the default texture, i.e., the image given is applied to all the faces of the box. If you want to change only 1 face or 1 side of the box, you can directly assign the values as shown below &minus;</p>
<pre class="prettyprint notranslate">
var hSpriteNb =  3;  // 3 sprites per raw
var vSpriteNb =  2;  // 2 sprite raws

var faceUV = new Array(6);
faceUV[4] = new BABYLON.Vector4(0, 0, 1/hSpriteNb, 1/vSpriteNb);
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 0, 1);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
            pl.diffuse = new BABYLON.Color3(1, 1, 1);
            pl.specular = new BABYLON.Color3(1, 1, 1);
            pl.intensity = 0.8;

            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            
            var texture = new BABYLON.Texture("images/3d.png", scene);
            mat.diffuseTexture = texture;

            var hSpriteNb =  3;  // 3 sprites per raw
            var vSpriteNb =  2;  // 2 sprite raws

            var faceUV = new Array(6);
            faceUV[4] = new BABYLON.Vector4(0, 0, 1/hSpriteNb, 1/vSpriteNb);

            var options = {
               width:3,
               height:3,
               depth: 3,
               faceUV:faceUV
            };

            var box = BABYLON.MeshBuilder.CreateBox("box", options, scene);
            box.material = mat;

            scene.registerBeforeRender(function() { 
               pl.position = camera.position;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/textturepahse4.jpg" alt="Textturepahse4" />
<p>In this demo, we have used an image called 3d.png. The images are stored in images/ folder locally and are also pasted below for reference. Please note 3d.png is a sprite image;  a sprite image is a collection of images. We wanted to show the image on a cube with all the sides of the cube together. You can also download similar sprite images of your choice and use in the demo link.</p>
<p>Texture used for box &minus; <b>images/3d.png</b></p>
<img src="/babylonjs/images/3d.jpg" alt="3d" />
<h2>MeshCylinder</h2>
<p>In this section, we will see how to create MeshCylinder. </p>
<p>To create MeshCylinder, you need to use the class BABYLON.MeshBuilder.CreateCylinder.</p>
<p>The parameters for the class are as follows &minus;</p>
<pre class="result notranslate">
var meshcylinder = BABYLON.MeshBuilder.CreateCylinder("meshcylinder", {
   height: 3,
   diameter: 35,
   tessellation: 52
}, scene);
</pre>
<p>The difference between CreateCylinder using mesh and meshbuilder is - you can use options in meshbuilder. Right now we are using height, diameter and tessellation as the options to be passed to the cylinder. We are using standard material with wireframe as the material for this mesh. Check the output in the browser and see the cylinder. You can use similar structure in your game as a wheel rotating in the scene.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;Babylon.js demo - Mesh Builder&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 6, 1.3, 40, new BABYLON.Vector3(0, -3, 0), scene);
            
            var light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);

            var mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.1, .5, 0);
            mat.specularColor = new BABYLON.Color3(0, 0, 0);
            mat.wireframe = true;

            var meshcylinder = BABYLON.MeshBuilder.CreateCylinder("meshcylinder", {
               height: 3,
               diameter: 35,
               tessellation: 52
            }, scene);

            meshcylinder.material = mat;
            meshcylinder.position = new BABYLON.Vector3(0, 0, 0);

            scene.activeCamera.attachControl(canvas);
            return scene;
         };
         
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/meshcylinder.jpg" alt="Meshcylinder" />
<p>A number of shapes created with mesh builder will now be used together in one demo. The shapes covered in the demo link below are listed in subsequent sections.</p>
<ul class="list">
<li><p><a href="/babylonjs/babylonjs_mesh_ground.htm">Ground</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_cone.htm">Cone</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_plane.htm">Plane</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_disc.htm">Disc</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_torus.htm">Torus</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_polyhedron.htm">Polyhedron</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_icosphere.htm">IcoSphere</a></p></li>
</ul>
<h2>BabylonJS –  Mesh Intersection and Point</h2>
<p>Mesh Intersection in games is important as you know what needs to be done when 2 objects intersect in a game. The same concept is explained in demo below on the event that needs to be captured when the meshes intersect.</p>
<p>In the demo given below, we have covered the following two concepts &minus;</p>
<ul class="list">
<li>Intersect Mesh</li>
<li>Intersect Point</li>
</ul>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
   &lt;meta charset = "utf-8"&gt;
   &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
   &lt;script src = "babylon.js"&gt;&lt;/script&gt;
   &lt;style&gt;
      canvas {width: 100%; height: 100%;}
   &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 1, 1);
            
            var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 20, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var matcone = new BABYLON.StandardMaterial("mat1", scene);
            matcone.alpha = 1.0;
            matcone.diffuseColor = new BABYLON.Color3(0, 0, 0);
            matcone.wireframe = true;

            var cone = BABYLON.MeshBuilder.CreateCylinder("cone", {height : 10, diameterTop: 10,diameterBottom:10, tessellation: 5}, scene);
            cone.position= new BABYLON.Vector3(12,1,0);
            cone.material = matcone;	

            var balloon1 = BABYLON.Mesh.CreateSphere("balloon1",5, 1.0, scene);
            var balloon2 = BABYLON.Mesh.CreateSphere("balloon2", 5, 1.0, scene);
            var balloon3 = BABYLON.Mesh.CreateSphere("balloon3", 5, 1.0, scene);
            
            balloon1.material = new BABYLON.StandardMaterial("matBallon", scene);
            balloon2.material = new BABYLON.StandardMaterial("matBallon", scene);
            balloon3.material = new BABYLON.StandardMaterial("matBallon", scene);

            balloon1.position = new BABYLON.Vector3(4, 2, 0);
            balloon2.position = new BABYLON.Vector3(5, 1, 0);
            balloon3.position = new BABYLON.Vector3(7, 0, 0);

            var pointToIntersect = new BABYLON.Vector3(10, 0, 0);
            var a = 0.01;
            
            scene.registerBeforeRender(function () {
               if (balloon1.intersectsMesh(cone, false)) {
                  balloon1.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
               } 
               else {
                  balloon1.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
               }

               if (balloon2.intersectsMesh(cone, false)) {
                  balloon2.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
               } 
               else {
                  balloon2.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
               }

               if (balloon3.intersectsMesh(cone, false)) {
                  balloon3.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
               } 
               else {
                  balloon3.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
               }

               if (balloon3.intersectsPoint(pointToIntersect)) {
                  balloon3.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
               }

               a += 0.01;
               balloon1.position.x += Math.cos(a) / 10;
               balloon2.position.x += Math.cos(a) / 10;
               balloon3.position.x += Math.cos(a) / 10;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above code generates the following output &minus;</p>
<img src="/babylonjs/images/mesh_intersection_point.jpg" alt="Mesh Intersection Point" />
<h3>Explanation</h3>
<p>With the above code, we created a cylinder with wireframe as true. We created 3 spheres. The original color of the sphere is green.</p>
<p>In the <b>scene.registerBeforeRender</b> function, we will change the color of the sphere based on intersection with the mesh which is the cylinder here.</p>
<p>Consider the following code in <b>registerBeforeRender</b> &minus;</p>
<pre class="prettyprint notranslate">
if (balloon1.intersectsMesh(cone, false)) {
   balloon1.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
} else {
   balloon1.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
}
</pre>
<p><b>intersectsMesh</b> gives true or false if it intersects with the mesh given in the parameter passed to it.</p>
<p>For example,</p>
<pre class="result notranslate">
balloon1.intersectsMesh(cone, false); //cone refers to the cylinder mesh here.
</pre>
<p>The color of the sphere is changed to red it intersects with the cylinder; otherwise, it is green.</p>
<p>Following code is used for the point to intersect &minus;</p>
<pre class="result notranslate">
var pointToIntersect = new BABYLON.Vector3(10, 0, 0);
if (balloon3.intersectsPoint(pointToIntersect)) {
   balloon3.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
}
</pre>
<p>Here, <b>pointtoIntersect</b> variable is the position vector which is 10 on x-axis. If the sphere crosses the point of intersect, the color of the sphere is changed to black.</p>
<h2>BabylonJS – MeshPicking Collision</h2>
<p>Picking collision actually gives you the coordinates and you can position your mesh in that place. The object is picked by the mouse and you can just place where you click with your mouse.Consider you need to place a mesh (object) at a place where the user clicks the mouse; so, with the help of picking collision it helps you with the co-ordinates at the position of the place clicked.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
      canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 1, 1);

            // setup environment
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 10, 20), scene);
            var freeCamera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 0, -30), scene);

            var balloon1 = BABYLON.Mesh.CreateSphere("balloon1",5, 1.0, scene);
            var balloon2 = BABYLON.Mesh.CreateSphere("balloon2", 5, 1.0, scene);
            balloon1.material = new BABYLON.StandardMaterial("matBallon", scene);
            balloon2.material = new BABYLON.StandardMaterial("matBallon", scene);

            balloon1.position = new BABYLON.Vector3(0, 0, -0.1);
            balloon2.position = new BABYLON.Vector3(0, 0, -0.1);
            balloon1.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
            balloon2.material.emissiveColor = new BABYLON.Color3(0, 0, 1);

            //Wall
            var wall = BABYLON.Mesh.CreatePlane("wall", 30.0, scene);
            wall.material = new BABYLON.StandardMaterial("wallMat", scene);
            wall.material.emissiveColor = new BABYLON.Color3(0.5, 1, 0.5);

            //When pointer down event is raised

            scene.onPointerDown = function (evt, pickResult) {
               // if the click hits the ground object, we change the impact position
               if (pickResult.hit) {
                  var dateValue = new Date();
                  var secondNumber = dateValue.getSeconds();
                  if (secondNumber % 2 == 0) {
                  balloon1.position.x = pickResult.pickedPoint.x;
                  balloon1.position.y = pickResult.pickedPoint.y;
                  } else {
                     balloon2.position.x = pickResult.pickedPoint.x;
                     balloon2.position.y = pickResult.pickedPoint.y;
                  }
               }
            };
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/picking_collision.jpg" alt="Picking collision" />
<h3>Explanation</h3>
<p>In the above example, we have used a plane and 2 spheres. To generate this output, use the following code &minus;</p>
<pre class="prettyprint notranslate">
scene.onPointerDown = function (evt, pickResult) {
   
   // if the click hits the ground object, we change the impact position
   if (pickResult.hit) {
      var dateValue = new Date();
      var secondNumber = dateValue.getSeconds();
      if (secondNumber % 2 == 0) {
      balloon1.position.x = pickResult.pickedPoint.x;
      balloon1.position.y = pickResult.pickedPoint.y;
      } 
      else {
         balloon2.position.x = pickResult.pickedPoint.x;
         balloon2.position.y = pickResult.pickedPoint.y;
      }
   }
};
</pre>
<p>The event <b>scene.onPointerDown</b> gives you the coordinated -x,y and z which in our example is <b>pickResult</b>.</p>
<p>It gives pickResult.hit as true if you click on the ground mesh. We consider odd/even seconds and change the position of the sphere to pick result z and y co-ordinates as shown above. Once the position is changed, the sphere is placed where you click and position your mouse. You can try the above demo for the same.</p>
<h2>BabylonJS – Raycasts</h2>
<p>Raycasts are like rays of sun and are used to check collision and intersection in the scene.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var ray = new BABYLON.Ray(origin, direction, length);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters for raycasts &minus;</p>
<ul class="list">
<li><p><b>Origin</b> &minus; Place where the ray will start.</p></li>
<li><p><b>Direction</b> &minus; Direction to the ray is calculated as follows &minus;</p></li>
</ul>
<pre class="result notranslate">
var forward = new BABYLON.Vector3(0,0,1);		
forward = vecToLocal(forward, box);
var direction = forward.subtract(origin);
</pre>
<p>Then, to get the direction, we subtract it from the origin, the box position &minus;</p>
<ul class="list">
<li><p><b>Length</b> &minus; Length of the ray.</p></li>
</ul>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 100, 100), scene);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0.8, 100, new BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            var ground = BABYLON.Mesh.CreateGround("ground", 500, 500, 10, scene);

            var box = BABYLON.Mesh.CreateBox("box", 4.0, scene);
            box.position.y = 2;
            box.scaling.z = 2;
           
            var matBox = new BABYLON.StandardMaterial("matBox", scene);
            matBox.diffuseColor = new BABYLON.Color3(0.8, 0.1, 0.5);
            box.material = matBox;
            box.isPickable = false; 

            var box2 = BABYLON.Mesh.CreateBox("box2", 8.0, scene);
            box2.position = new BABYLON.Vector3(-20, 4, 0); 
            
            var matBox2 = new BABYLON.StandardMaterial("matBox2", scene);
            matBox2.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box2.material = matBox2;

            var box3 = BABYLON.Mesh.CreateBox("box3", 8.0, scene);
            box3.position = new BABYLON.Vector3(20, 4, 0); 
            
            var matBox3 = new BABYLON.StandardMaterial("matBox3", scene);
            matBox3.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box3.material = matBox3;

            var box4 = BABYLON.Mesh.CreateBox("box4", 8.0, scene);
            box4.position = new BABYLON.Vector3(0, 0, 20); 
            
            var matBox4 = new BABYLON.StandardMaterial("matBox4", scene);
            matBox4.diffuseColor = new BABYLON.Color3(0, 1, 0);
            box4.material = matBox4;

            var box5 = BABYLON.Mesh.CreateBox("box5", 8.0, scene);
            box5.position = new BABYLON.Vector3(0, 0, -20); 
            
            var matBox5 = new BABYLON.StandardMaterial("matBox5", scene);
            matBox5.diffuseColor = new BABYLON.Color3(0, 1, 0);
            box5.material = matBox5;

            function mousemovef() {
               var pickResult = scene.pick(scene.pointerX, scene.pointerY);

               if (pickResult.hit) {
                  var diffX = pickResult.pickedPoint.x - box.position.x;
                  var diffY = pickResult.pickedPoint.z - box.position.z;
                  box.rotation.y = Math.atan2(diffX,diffY);			
               }	
            }

            scene.onPointerMove = function () {
               mousemovef();
            };

            function vecToLocal(vector, mesh) {
               var m = mesh.getWorldMatrix();
               var v = BABYLON.Vector3.TransformCoordinates(vector, m);
               return v;		
            }   

            scene.registerBeforeRender(function () {
               var origin = box.position;

               var forward = new BABYLON.Vector3(0,0,1);		
               forward = vecToLocal(forward, box);

               var direction = forward.subtract(origin);
               direction = BABYLON.Vector3.Normalize(direction);

               var length = 100;

               var ray = new BABYLON.Ray(origin, direction, length);
               // ray.show(scene, new BABYLON.Color3(1, 1, 0.1));

               var hit = scene.pickWithRay(ray);

               if (hit.pickedMesh) {
                  hit.pickedMesh.scaling.y  += 0.01;
               }
            });		
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/raycast.jpg" alt="Raycast" />
<h3>Explanation</h3>
<p>There is a main box at the center which acts as a raycast. The moment it points to any of the boxes, the size of the box will increase. This concept proves useful while playing games to know which other object is coming into contact and necessary action can be taken.</p>
<p>Adding <b>box.isPickable = false;</b> so that the main box at the center is not considered. If you do not want any object to be included in the rays to come into contact, add <b>box.isPickable = false;</b> to it.</p>
<p>The following code adds scaling ofhe box which is picked by the ray.</p>
<pre class="prettyprint notranslate">
scene.registerBeforeRender(function () {
   var origin = box.position;	
   var forward = new BABYLON.Vector3(0,0,1);		
   forward = vecToLocal(forward, box);

   var direction = forward.subtract(origin);
   direction = BABYLON.Vector3.Normalize(direction);

   var length = 100;

   var ray = new BABYLON.Ray(origin, direction, length);

   var hit = scene.pickWithRay(ray);

   if (hit.pickedMesh) {
      hit.pickedMesh.scaling.y  += 0.01;
   }
});	
</pre>
<p><b>var ray = new BABYLON.Ray(origin, direction, length);</b> creates a ray and it takes the main box position as the origin.</p>
<p>Direction to the ray is calculated as follows &minus;</p>
<pre class="result notranslate">
var forward = new BABYLON.Vector3(0,0,1);		
forward = vecToLocal(forward, box);
var direction = forward.subtract(origin);
</pre>
<p>Then, to get the direction, we subtract it from the origin, the box position. The function <b>vecToLocal</b> is designed to transform a position from a mesh point of view by multiplicating a vector by the mesh matrix.</p>
<p>We get the hit point from the ray using <b>var hit = scene.pickWithRay(ray);</b></p>
<p>It gives the position where the ray coincides with the mesh.</p>
<p>The scaling is applied to the mesh which is picked by executing the following line of code &minus;</p>
<pre class="result notranslate">
if (hit.pickedMesh) {
   hit.pickedMesh.scaling.y  += 0.01;
}
</pre>
<p>Try the above example in the browser to see the output.</p>
<h3>Raycast with predicate function</h3>
<p>Let us now see how the raycast with predicate function works and the direction shown with rayhelper.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 100, 100), scene);
            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0.8, 100, new BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            var ground = BABYLON.Mesh.CreateGround("ground", 500, 500, 10, scene);

            var box = BABYLON.Mesh.CreateBox("box", 4.0, scene);
            box.position.y = 2;
            box.scaling.z = 2;
            var matBox = new BABYLON.StandardMaterial("matBox", scene);
            matBox.diffuseColor = new BABYLON.Color3(0.8, 0.1, 0.5);
            box.material = matBox;
            box.isPickable = false; 

            var box2 = BABYLON.Mesh.CreateBox("box2", 8.0, scene);
            box2.position = new BABYLON.Vector3(-20, 4, 0); 
            var matBox2 = new BABYLON.StandardMaterial("matBox2", scene);
            matBox2.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box2.material = matBox2;

            var box3 = BABYLON.Mesh.CreateBox("box3", 8.0, scene);
            box3.position = new BABYLON.Vector3(20, 4, 0); 
            var matBox3 = new BABYLON.StandardMaterial("matBox3", scene);
            matBox3.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box3.material = matBox3;

            var box4 = BABYLON.Mesh.CreateBox("box4", 8.0, scene);
            box4.position = new BABYLON.Vector3(0, 0, 20); 
            var matBox4 = new BABYLON.StandardMaterial("matBox4", scene);
            matBox4.diffuseColor = new BABYLON.Color3(0, 1, 0);
            box4.material = matBox4;

            var box5 = BABYLON.Mesh.CreateBox("box5", 8.0, scene);
            box5.position = new BABYLON.Vector3(0, 0, -20); 
            var matBox5 = new BABYLON.StandardMaterial("matBox5", scene);
            matBox5.diffuseColor = new BABYLON.Color3(0, 1, 0);
            box5.material = matBox5;

            //ray showing the direction
            var ray = new BABYLON.Ray();
            var rayHelper = new BABYLON.RayHelper(ray);

            var localMeshDirection = new BABYLON.Vector3(0, 0, -1);
            var localMeshOrigin = new BABYLON.Vector3(0, 0, -.4);
            var length = 10;

            rayHelper.attachToMesh(box, localMeshDirection, localMeshOrigin, length);
            rayHelper.show(scene);

            function mousemovef() {
               var pickResult = scene.pick(scene.pointerX, scene.pointerY);

               if (pickResult.hit) {
                  var diffX = pickResult.pickedPoint.x - box.position.x;
                  var diffY = pickResult.pickedPoint.z - box.position.z;
                  box.rotation.y = Math.atan2(diffX,diffY);			
               }	
            }

            scene.onPointerMove = function () {
               mousemovef();
            };

            function vecToLocal(vector, mesh) {
               var m = mesh.getWorldMatrix();
               var v = BABYLON.Vector3.TransformCoordinates(vector, m);
               return v;		
            }   

            scene.registerBeforeRender(function () {
               var origin = box.position;
               function predicate(mesh) {
                  if (mesh == box2 || mesh == box || mesh == box5) {
                     return false;
                  }
                  return true;
               }
               
               var forward = new BABYLON.Vector3(0,0,1);		
               forward = vecToLocal(forward, box);

               var direction = forward.subtract(origin);
               direction = BABYLON.Vector3.Normalize(direction);

               var length = 100;

               var ray = new BABYLON.Ray(origin, direction, length);
               // ray.show(scene, new BABYLON.Color3(1, 1, 0.1));

               var hit = scene.pickWithRay(ray, predicate);
               if (hit.pickedMesh) {
                  hit.pickedMesh.scaling.y  += 0.01;
               }
            });		
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/raycast_predicate.jpg" alt="Raycast Predicate" />
<h3>Explanation</h3>
<p>Raycast with predicate function helps to choose which mesh we want. If we do not want a mesh to be picked, we can ignore the same.</p>
<pre class="prettyprint notranslate">
function predicate(mesh) {
   if (mesh == box2 || mesh == box || mesh == box5) {
      return false;
   }
   return true;
}
</pre>
<p>The above function gives the mesh which is selected by the ray. If the mesh selected is box2, box, or box5, it will return false; otherwise, true.</p>
<p>You can try the above example for the same.</p>
<h2>BabylonJS – Mesh Shadows</h2>
<p>Shadows are rendered based on the way light falls on the mesh created. They play an important role towards making the output look realistic in the 3D world.</p>
<p>Let us now learn how to create shadows using babylonjs.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var shadowGenerator00 = new BABYLON.ShadowGenerator(shadowsize, light);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to mesh shadows &minus;</p>
<ul class="list">
<li><p><b>Shadowsize</b> &minus; Size of the shadow.</p></li>
<li><p><b>Light</b> &minus; Light used in the scene.</p></li>
</ul>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(1, 1, 1);	
            var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 20, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            // light1
            var light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(-1, -2, -1), scene);
            light.position = new BABYLON.Vector3(20, 40, 20);

            var ground01 = BABYLON.Mesh.CreateGround("Spotlight Hard Shadows", 24, 60, 1, scene, false);
            var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("images/gr1.jpg", scene);
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            groundMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            ground01.material = groundMaterial;
            ground01.receiveShadows = true;
            ground01.position.x = -5;

            var box = BABYLON.Mesh.CreateBox("box", 3.0, scene);
            box.position.x = -5;
            box.position.y = 5;
            var shadowGenerator00 = new BABYLON.ShadowGenerator(512, light);
            shadowGenerator00.getShadowMap().renderList.push(box);
            //shadowGenerator00.usePoissonSampling = true;
            //shadowGenerator00.useExponentialShadowMap = true;
            shadowGenerator00.useBlurExponentialShadowMap = true;
            shadowGenerator00.bias = 0.01;
            scene.registerBeforeRender(function() {
               box.rotation.x += 0.01;
               box.rotation.x += 0.01;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/shadows.jpg" alt="Shadows" />
<h3>Explanation</h3>
<p>To create shadows, you need to create the shadowgenerator. Consider an example shown below.</p>
<pre class="result notranslate">
var shadowGenerator00 = new BABYLON.ShadowGenerator(512, light);
</pre>
<p>To define the mesh for which the shadow is required, you need to add the same to above generator.</p>
<pre class="result notranslate">
shadowGenerator00.getShadowMap().renderList.push(box);
</pre>
<p>Now, we have created a ground and a box on top of it. We want the shadow of the box to fall on the ground. To do that, we need to make sure the ground is marked to receive shadow which is done as follows &minus;</p>
<pre class="result notranslate">
ground01.receiveShadows = true;
</pre>
<p>There are some filters available for shadows which are as follows &minus;</p>
<pre class="result notranslate">
shadowGenerator.usePoissonSampling = true; - Called Poisson sampling 
shadowGenerator.useExponentialShadowMap = true; - Exponential Shadow Map
shadowGenerator.useBlurExponentialShadowMap= true;  - Blur Exponential Shadow Map
</pre>
<p>In our demo, we have used shadowGenerator00.useBlurExponentialShadowMap = true; You can try the others and see how the output looks like.</p>
<p>Here, we have used image called gr1.jpg. The images are stored in the images/ folder locally. You can download any image of your choice and use in the demo link.</p>
<h2>BabylonJS – Advanced Textures on Meshes</h2>
<p>In this section, we will learn about the advanced textures on meshes. The different textures are shown below &minus;</p>
<ul class="list">
<li><p><a href="/babylonjs/babylonjs_mesh_cube_texture.htm">Cube Texture</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_mirror_bump_texture.htm">Mirror and Bump Texture</a></p></li>
<li><p><a href="/babylonjs/babylonjs_mesh_video_texture.htm">Video Texture</a></p></li>
</ul>
<p>Let us apply some complex texture to the mesh – mirror, bump, video and refraction.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No.</th>
<th style="text-align:center;">Mesh &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><a href="/babylonjs/babylonjs_meshhighlight_layer.htm">MeshHightlight Layer</a>
<p>Highlight layer is used to highlight the mesh in the scene. You can give color to it and the color is applied to the borders of the mesh. In case in a game you want to hightlight, the mesh hightlight layer can be used for the same.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><a href="/babylonjs/babylonjs_morph_mesh.htm">Morph a Mesh</a>
<p>Morphing changes the shape of an object to another by  some means of transition. We have seen the updatable parameter for the shapes; the parameter is set to false otherwise. For morphing, it is set to true and the mesh is updated to change the shape.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><a href="/babylonjs/babylonjs_actions_to_mesh.htm">Actions to Mesh</a>
<p>Actions are used to add interaction to the mesh. Events are activated when you click on the mesh, or when mesh intersects or collides.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><a href="/babylonjs/babylonjs_mesh_assetsmanager.htm">Mesh AssetsManager</a>
<p>With assestsmanager class, you can load meshes, images and binaryfiles in the scene.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><a href="/babylonjs/babylonjs_import_mesh.htm">Import Mesh</a>
<p>Using Import Mesh we will learn.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><a href="/babylonjs/babylonjs_mesh_morph_targets.htm">Mesh Morph Targets</a>
<p>We have already seen morhphing of lines, ribbon, polygon, etc. Now, we will see morphing of sphere and box in this demo.With morph targets, the shape of the sphere is changed which is seen in the demo below.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><a href="/babylonjs/babylonjs_mesh_instances.htm">Mesh Instances</a>
<p>If you want to draw identical meshes in your scene , make use of the instances.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><a href="/babylonjs/babylonjs_mesh_lod_and_instances.htm">Mesh LOD &amp; Instances</a>
<p>LOD stands for line of distance. This feature allows you to specify meshes based on the distance of the viewer. As the distance from the viewer to the object increases, the level of detail for the mesh is shown clearly using LOD.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><a href="/babylonjs/babylonjs_mesh_volumemetriclightscatteringpostprocess.htm">Mesh VolumemetricLightScatteringPost-process</a>
<p>This process scatters the light as shown in the output given below. Test the same in browser and you will see how the light scatters through the mesh.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><a href="/babylonjs/babylonjs_mesh_edgesrenderer.htm">Mesh EdgesRenderer</a>
<p>EdgesRendering is used to draw egdes around the mesh as shown in the output above.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><a href="/babylonjs/babylonjs_mesh_blendmodes.htm">Mesh BlendModes</a>
<p>You can create a blend mode by modifying the alphamode of the materials.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><a href="/babylonjs/babylonjs_mesh_solidparticles.htm">Mesh SolidParticles</a>
<p>SolidParticle System is updated on a mesh. All the properties that we have seen on a mesh can be used on the solid partilcle.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><a href="/babylonjs/babylonjs_mesh_facetdata.htm">Mesh FacetData</a>
<p>Facet data takes up a lot of memory and this feature is not enabled by default. To enable it, we need to create a mesh as required and update facet data to it.</p></td>
</tr>
</table>
<h1>BabylonJS - VectorPosition and Rotation</h1>
<p>Run the demo links given below in your browser. In the demos given below, we have drawn the x,y and z-axis. There are numbers plotted on the x,y and z-axis in the positive and negative direction. Run the same in browser, change the values in case you need and draw your shapes, meshes, position them and see how they render in the x, y and z –axis.With the numbers mentioned on the x,y and z axis, it will be helpful to see how the positioning of the mesh is done.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);

            // camera
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
            camera.setPosition(new BABYLON.Vector3(5, 10, -10));
            camera.attachControl(canvas, true);
            
            // lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            light.intensity = 0.8;
            var spot = new BABYLON.SpotLight(
               "spot", 
               new BABYLON.Vector3(25, 15, -10), 
               new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
            spot.diffuse = new BABYLON.Color3(1, 1, 1);
            spot.specular = new BABYLON.Color3(0, 0, 0);
            spot.intensity = 0.2; 
            
            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            //mat.wireframe = true;

            // show axis
            var showAxis = function(size) {
               var makeTextPlane = function(text, color, size) {
                  var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
                  dynamicTexture.hasAlpha = true;
                  dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
                  
                  var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
                  plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
                  plane.material.backFaceCulling = false;
                  
                  plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
                  plane.material.diffuseTexture = dynamicTexture;
                  return plane;
               };

               var axisX = BABYLON.Mesh.CreateLines("axisX", [ 
                  new BABYLON.Vector3(-size * 0.95, 0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0), 
                  new BABYLON.Vector3(-size * 0.95, -0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0),
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, 0.05 * size, 0), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
               ], scene);
               
               axisX.color = new BABYLON.Color3(1, 0, 0);
               var xChar = makeTextPlane("X", "red", size / 10);
               xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);

               var xChar1 = makeTextPlane("-X", "red", size / 10);
               xChar1.position = new BABYLON.Vector3(-0.9 * size, 0.05 * size, 0);

               var axisY = BABYLON.Mesh.CreateLines("axisY", [
                  new BABYLON.Vector3( -0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3(0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( -0.05 * size, size * 0.95, 0), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
               ], scene);
               
               axisY.color = new BABYLON.Color3(0, 1, 0);
               var yChar = makeTextPlane("Y", "green", size / 10);
               yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
               var yChar1 = makeTextPlane("-Y", "green", size / 10);
               yChar1.position = new BABYLON.Vector3(0, -0.9 * size, 0.05 * size);

               var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                  new BABYLON.Vector3( 0 , -0.05 * size, -size * 0.95), 
                  new BABYLON.Vector3(0, 0, -size),
                  new BABYLON.Vector3( 0 , 0.05 * size, -size * 0.95),
                  new BABYLON.Vector3(0, 0, -size), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
               ], scene);
               
               axisZ.color = new BABYLON.Color3(0, 0, 1);
               var zChar = makeTextPlane("Z", "blue", size / 10);
               zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
               var zChar1 = makeTextPlane("-Z", "blue", size / 10);
               zChar1.position = new BABYLON.Vector3(0, 0.05 * size, -0.9 * size);
            };
            showAxis(10);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<img src="/babylonjs/images/vector.jpg" alt="Vector" />
<p>Let us have the co-ordinates defined along the x, y and z axis.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);

            // camera
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
            camera.setPosition(new BABYLON.Vector3(5, 10, -10));
            camera.attachControl(canvas, true);
            
            // lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            light.intensity = 0.8;
            var spot = new BABYLON.SpotLight(
               "spot", new BABYLON.Vector3(25, 15, -10), 
               new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
            spot.diffuse = new BABYLON.Color3(1, 1, 1);
            spot.specular = new BABYLON.Color3(0, 0, 0);
            spot.intensity = 0.2; 
            
            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            
            //mat.wireframe = true;
            var makeTextPlane = function(text, color, size) {
               var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
               dynamicTexture.hasAlpha = true;
               dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
               
               var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
               plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
               plane.material.backFaceCulling = false;
               plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
               plane.material.diffuseTexture = dynamicTexture;
               return plane;
            };
            
            // show axis
            var showAxis = function(size) {
               var axisX = BABYLON.Mesh.CreateLines("axisX", [ 
                  new BABYLON.Vector3(-size * 0.95, 0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0), 
                  new BABYLON.Vector3(-size * 0.95, -0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0),
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, 0.05 * size, 0), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
               ], scene);
               axisX.color = new BABYLON.Color3(1, 0, 0);
               var xChar = makeTextPlane("X", "red", size / 10);
               xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);

               var xChar1 = makeTextPlane("-X", "red", size / 10);
               xChar1.position = new BABYLON.Vector3(-0.9 * size, 0.05 * size, 0);
               var xcor = [];
               for (i =- 10; i &lt;= 10; i++) {
                  xcor[i] = makeTextPlane(i, "red", size / 10);
                  xcor[i].position = new BABYLON.Vector3(i, 0, 0);
               }

               var axisY = BABYLON.Mesh.CreateLines("axisY", [
                  new BABYLON.Vector3( -0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3(0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( -0.05 * size, size * 0.95, 0), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
               ], scene);
               
               axisY.color = new BABYLON.Color3(0, 1, 0);
               var yChar = makeTextPlane("Y", "green", size / 10);
               yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
               var yChar1 = makeTextPlane("-Y", "green", size / 10);
               yChar1.position = new BABYLON.Vector3(0, -0.9 * size, 0.05 * size);

               var ycor = [];
               for (y=-10;y&lt;=10;y++) {
                  xcor[y] = makeTextPlane(y, "green", size / 10);
                  xcor[y].position = new BABYLON.Vector3(0, y, 0);
               }		

               var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                  new BABYLON.Vector3( 0 , -0.05 * size, -size * 0.95), 
                  new BABYLON.Vector3(0, 0, -size),
                  new BABYLON.Vector3( 0 , 0.05 * size, -size * 0.95),
                  new BABYLON.Vector3(0, 0, -size), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
               ], scene);
               
               axisZ.color = new BABYLON.Color3(0, 0, 1);
               var zChar = makeTextPlane("Z", "blue", size / 10);
               zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
               var zChar1 = makeTextPlane("-Z", "blue", size / 10);
               zChar1.position = new BABYLON.Vector3(0, 0.05 * size, -0.9 * size);

               var zcor = [];
               for (z =- 10; z &lt;= 10; z++) {
                  xcor[z] = makeTextPlane(z, "green", size / 10);
                  xcor[z].position = new BABYLON.Vector3(0, 0, z);
               }
            };	

            //Lets draw a mesh along the axis.

            var spriteManagerPlayer = new BABYLON.SpriteManager("playerManager", "images/bird.png", 1, 200, scene);
            var player = new BABYLON.Sprite("player", spriteManagerPlayer);
            player.position.x = 2;
            player.position.y = 2;	
            player.position.z = 0;	

            var zChardot = makeTextPlane(".", "red", 1);		
            zChardot.position = new BABYLON.Vector3(1.8, 1.8,0);

            var box = BABYLON.Mesh.CreateBox("box", '2', scene);
            box.position = new BABYLON.Vector3(-5,3,0); // center point of box x-axis is -5 and y axis is 3.

            var box = BABYLON.Mesh.CreateBox("box", '2', scene);
            box.position = new BABYLON.Vector3(0,3,-3); // center point of box x-axis is -5 and y axis is 3.

            var redSphere = BABYLON.Mesh.CreateSphere("red", 32, 1, scene); //no position for sphere so by default it takes 0,0,0
            showAxis(10);
            returnscene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<p>In this demo, we have used image bird.png. The images are stored in the images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<p><b>Images/bird.png</b></p>
<img src="/babylonjs/images/bird.jpg" alt="Bird" />
<p></p>
<img src="/babylonjs/images/vetex_coordinates.jpg" alt="Vetex Coordinates" />
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
   &lt;meta charset = "utf-8"&gt;
   &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
   &lt;script src = "babylon.js"&gt;&lt;/script&gt;
   &lt;style&gt;
   canvas {width: 100%; height: 100%;}
   &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);

            // camera
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
            camera.setPosition(new BABYLON.Vector3(5, 10, -10));
            camera.attachControl(canvas, true);
            
            // lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            light.intensity = 0.8;
            
            var spot = new BABYLON.SpotLight(
               "spot", 
               new BABYLON.Vector3(25, 15, -10), 
               new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
            spot.diffuse = new BABYLON.Color3(1, 1, 1);
            spot.specular = new BABYLON.Color3(0, 0, 0);
            spot.intensity = 0.2; 
            
            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            
            //mat.wireframe = true;
            var makeTextPlane = function(text, color, size) {
               var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
               dynamicTexture.hasAlpha = true;
               dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
               var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
               plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
               plane.material.backFaceCulling = false;
               plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
               plane.material.diffuseTexture = dynamicTexture;
               return plane;
            };
            
            // show axis
            var showAxis = function(size) {	
               var axisX = BABYLON.Mesh.CreateLines("axisX", [ 
                  new BABYLON.Vector3(-size * 0.95, 0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0), 
                  new BABYLON.Vector3(-size * 0.95, -0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0),
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, 0.05 * size, 0), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)], scene);
               axisX.color = new BABYLON.Color3(1, 0, 0);
               var xChar = makeTextPlane("X", "red", size / 10);
               xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);

               var xChar1 = makeTextPlane("-X", "red", size / 10);
               xChar1.position = new BABYLON.Vector3(-0.9 * size, 0.05 * size, 0);
               var xcor = [];
               for (i =- 10; i &lt;= 10; i++) {
                  xcor[i] = makeTextPlane(i, "red", size / 10);
                  xcor[i].position = new BABYLON.Vector3(i, 0, 0);
               }

               var axisY = BABYLON.Mesh.CreateLines("axisY", [
                  new BABYLON.Vector3( -0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3(0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( -0.05 * size, size * 0.95, 0), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
               ], scene);
               
               axisY.color = new BABYLON.Color3(0, 1, 0);
               var yChar = makeTextPlane("Y", "green", size / 10);
               yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
               var yChar1 = makeTextPlane("-Y", "green", size / 10);
               yChar1.position = new BABYLON.Vector3(0, -0.9 * size, 0.05 * size);

               var ycor = [];
               for (y =- 10; y &lt;= 10; y++) {
                  xcor[y] = makeTextPlane(y, "green", size / 10);
                  xcor[y].position = new BABYLON.Vector3(0, y, 0);
               }

               var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                  new BABYLON.Vector3( 0 , -0.05 * size, -size * 0.95), 
                  new BABYLON.Vector3(0, 0, -size),
                  new BABYLON.Vector3( 0 , 0.05 * size, -size * 0.95),
                  new BABYLON.Vector3(0, 0, -size), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
               ], scene);
               axisZ.color = new BABYLON.Color3(0, 0, 1);
               var zChar = makeTextPlane("Z", "blue", size / 10);
               zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
               var zChar1 = makeTextPlane("-Z", "blue", size / 10);
               zChar1.position = new BABYLON.Vector3(0, 0.05 * size, -0.9 * size);

               var zcor = [];
               for (z =- 10; z &lt;= 10; z++) {
                  xcor[z] = makeTextPlane(z, "green", size / 10);
                  xcor[z].position = new BABYLON.Vector3(0, 0, z);
               }
            };

            var kite = BABYLON.Mesh.CreateLines("kite", [
               new BABYLON.Vector3(-4,0,0),
               new BABYLON.Vector3(0,4,0), 
               new BABYLON.Vector3(4,0,0), 
               new BABYLON.Vector3(0,-4,0),
               new BABYLON.Vector3(-4,0,0)
            ], scene);
            kite.color = new BABYLON.Color3(1, 1, 1);

            var path = [];
            path.push(new BABYLON.Vector3(-4, 0, 0));
            path.push(new BABYLON.Vector3(0, 0, 0));
            path.push(new BABYLON.Vector3(4, 0, 0));

            var lines1 = BABYLON.Mesh.CreateLines("lines",path, scene, true);
            lines1.color = new BABYLON.Color3(1, 1, 1);
            showAxis(10);	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code will generate the following output:</p>
<img src="/babylonjs/images/vectormode.jpg" alt="Vectormode" />
<h2>Vector Rotate</h2>
<p>Let us now see how the vector rotate works.</p>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);

            // camera
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas, true);
            
            // lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            light.intensity = 0.8;
            var spot = new BABYLON.SpotLight(
               "spot", 
               new BABYLON.Vector3(25, 15, -10), 
               new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
            spot.diffuse = new BABYLON.Color3(1, 1, 1);
            spot.specular = new BABYLON.Color3(0, 0, 0);
            spot.intensity = 0.2; 
            
            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            
            //mat.wireframe = true;
            var makeTextPlane = function(text, color, size) {
               var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
               dynamicTexture.hasAlpha = true;
               dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
               var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
               plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
               plane.material.backFaceCulling = false;
               plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
               plane.material.diffuseTexture = dynamicTexture;
               return plane;
            };
            // show axis
            var showAxis = function(size) {
               var axisX = BABYLON.Mesh.CreateLines("axisX", [ 
                  new BABYLON.Vector3(-size * 0.95, 0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0), 
                  new BABYLON.Vector3(-size * 0.95, -0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0),
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, 0.05 * size, 0), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
               ], scene);
               
               axisX.color = new BABYLON.Color3(1, 0, 0);
               var xChar = makeTextPlane("X", "red", size / 10);
               xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);

               var xChar1 = makeTextPlane("-X", "red", size / 10);
               xChar1.position = new BABYLON.Vector3(-0.9 * size, 0.05 * size, 0);
               var xcor = [];
               for (i =- 10; i &lt;= 10; i++) {
                  xcor[i] = makeTextPlane(i, "red", size / 10);
                  xcor[i].position = new BABYLON.Vector3(i, 0, 0);
               }

               var axisY = BABYLON.Mesh.CreateLines("axisY", [
                  new BABYLON.Vector3( -0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3(0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( -0.05 * size, size * 0.95, 0), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
               ], scene);
               
               axisY.color = new BABYLON.Color3(0, 1, 0);
               var yChar = makeTextPlane("Y", "green", size / 10);
               yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
               var yChar1 = makeTextPlane("-Y", "green", size / 10);
               yChar1.position = new BABYLON.Vector3(0, -0.9 * size, 0.05 * size);

               var ycor = [];
               for (y =- 10; y &lt;= 10; y++) {
                  xcor[y] = makeTextPlane(y, "green", size / 10);
                  xcor[y].position = new BABYLON.Vector3(0, y, 0);
               }

               var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                  new BABYLON.Vector3( 0 , -0.05 * size, -size * 0.95), 
                  new BABYLON.Vector3(0, 0, -size),
                  new BABYLON.Vector3( 0 , 0.05 * size, -size * 0.95),
                  new BABYLON.Vector3(0, 0, -size), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
               ], scene);
               
               axisZ.color = new BABYLON.Color3(0, 0, 1);
               var zChar = makeTextPlane("Z", "blue", size / 10);
               zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
               var zChar1 = makeTextPlane("-Z", "blue", size / 10);
               zChar1.position = new BABYLON.Vector3(0, 0.05 * size, -0.9 * size);

               var zcor = [];
               for (z =- 10; z &lt;= 10; z++) {
                  xcor[z] = makeTextPlane(z, "green", size / 10);
                  xcor[z].position = new BABYLON.Vector3(0, 0, z);
               }
            };

            var yellowSphere = BABYLON.Mesh.CreateSphere("yellowSphere",32, 1, scene);
            yellowSphere.setPivotMatrix(BABYLON.Matrix.Translation(2, 0, 0));
            var yellowMaterial = new BABYLON.StandardMaterial("yellowMaterial", scene);
            yellowMaterial.diffuseColor = BABYLON.Color3.Yellow();
            yellowSphere.material = yellowMaterial;

            var wheel1 = BABYLON.MeshBuilder.CreateTorus('t1', {diameter: 2.0}, scene);
            wheel1.position.x = -2.0
            wheel1.position.z = -2.0;

            showAxis(10);	
            var k = 0.0;
            var y = 0.0;
            var x = 0.0;
            scene.registerBeforeRender(function () {
               wheel1.rotation.copyFromFloats(0.0, 0.0, Math.PI / 2);
               wheel1.addRotation(0.0, y, 0.0); 
               wheel1.addRotation(x, 0.0, 0.0);
               yellowSphere.rotation.y += 0.01;
               y += 0.05; 
            });	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/vector_rotate.jpg" alt="Vector Rotate" />
<h1>BabylonJS - Decals</h1>
<p>Decals are likes stickers pasted on anobject. The sticker drawing is done with the help of  2d image which is drawn on the mesh (for example, object in the game). In games, consider you have an army firing bullets, the bullet impression needs to be seen on the object. So in Babylonjs, it is done using decals wherein, when you click on any object you will draw a 2D image on the place where you clicked it.</p>
<p>Decals are used to add details on the created mesh – details like bullets, holes, etc. In the demo link given below, we are using an image and adding the same to the imported mesh.</p>
<p>To add decal, you can use the following code &minus;</p>
<pre class="result notranslate">
var newDecal = BABYLON.Mesh.CreateDecal("decal", mesh, decalPosition, normal, decalSize, angle);
</pre>
<p>Following code is executed to add decals on the mesh &minus;</p>
<pre class="prettyprint notranslate">
BABYLON.SceneLoader.ImportMesh("Shcroendiger'scat", "scenes/", "SSAOcat.babylon", scene, function (newMeshes) {
   var cat = newMeshes[0]; / /this is mesh shown on the screen.

   // Set the target of the camera to the first imported mesh
   camera.target = cat;

   var decalMaterial = new BABYLON.StandardMaterial("decalMat", scene);
   decalMaterial.diffuseTexture = new BABYLON.Texture("images/impact1.jpg", scene);
   decalMaterial.diffuseTexture.hasAlpha = true;
   decalMaterial.zOffset = -2;

   var onPointerDown = function (evt) {
      if (evt.button !== 0) {
         return;
      }

      // check if we are under a mesh
      var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh === cat; 
      // this will give all the meshes , but it will pick the mesh whch is same as cat and return true if it is found });
      if (pickInfo.hit) { // if true
         var decalSize = new BABYLON.Vector3(5, 5, 5); //size of decal is defined

         var newDecal = BABYLON.Mesh.CreateDecal("decal", cat, pickInfo.pickedPoint, pickInfo.getNormal(true), decalSize); //decal is created 
         newDecal.material = decalMaterial; //decal material is added.
      }
   }
   var canvas = engine.getRenderingCanvas();
   canvas.addEventListener("pointerdown", onPointerDown, false);

   scene.onDispose = function () {
      canvas.removeEventListener("pointerdown", onPointerDown);
   }
});
</pre>	
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            //Adding a light
            var light = new BABYLON.HemisphericLight("Hemi", new BABYLON.Vector3(0, 1, 0), scene);

            //Adding an Arc Rotate Camera
            var camera = new BABYLON.ArcRotateCamera("Camera", -1.85, 1.2, 200, BABYLON.Vector3.Zero(), scene);

            camera.attachControl(canvas, true);

            // The first parameter can be used to specify which mesh to import. Here we import all meshes
            BABYLON.SceneLoader.ImportMesh("Shcroendiger'scat", "scenes/", "SSAOcat.babylon", scene, function (newMeshes) {
               var cat = newMeshes[0];

               // Set the target of the camera to the first imported mesh
               camera.target = cat;

               var decalMaterial = new BABYLON.StandardMaterial("decalMat", scene);
               decalMaterial.diffuseTexture = new BABYLON.Texture("images/impact1.jpg", scene);
               decalMaterial.diffuseTexture.hasAlpha = true;
               decalMaterial.zOffset = -2;

               var onPointerDown = function (evt) {
                  if (evt.button !== 0) {
                     return;
                  }

                  // check if we are under a mesh
                  var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh === cat; });
                  if (pickInfo.hit) {
                     var decalSize = new BABYLON.Vector3(5, 5, 5);

                     var newDecal = BABYLON.Mesh.CreateDecal("decal", cat, pickInfo.pickedPoint, pickInfo.getNormal(true), decalSize);
                     newDecal.material = decalMaterial;
                  }
               }
               var canvas = engine.getRenderingCanvas();
               canvas.addEventListener("pointerdown", onPointerDown, false);

               scene.onDispose = function () {
                  canvas.removeEventListener("pointerdown", onPointerDown);
               }
            });	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>In the above demo link, we have used SSAOcat.babylon mesh. You can download the json file for SSAOcat.babylon from here &minus;</p>
<p><a href="https://raw.githubusercontent.com/BabylonJS/Babylon.js/master/Playground/scenes/SSAOcat.babylon" target="_blank" rel="nofollow">SSAOcat.babylon</a></p>
<p>Save the file in scenes/ folder. This will help you get the output as shown below.</p>
<h3>Output</h3>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/decals.jpg" alt="Decals" />
<p>In this demo, we have used image <b>impact1.jpg</b>. The images are stored in the images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<p><b>images/impact1.jpg</b></p>
<img src="/babylonjs/images/impact1.jpg" alt="Impact1" />
<h1>BabylonJS - Curve3</h1>
<p>BabylonJS has built in api to create some of the complex mathematics curve. We have earlier seen ribbon, lines created using complex equation to draw the pattern and calculate the co-ordinates for the paths given to the mesh. We have a built-in API here to avoid doing complex calculation, just like in Curves API.</p>
<p>The curves which are explained are as follows &minus;</p>
<ul class="list">
<li>Quadratic Bezier curve</li>
<li>Cubic Bezier curve</li>
<li>Hermite spline</li>
<li>Catmull-Rom spline</li>
</ul>
<h2>Quadratic Bezier Curve</h2>
<p>In this section, we will learn about the Quadratic Bezier Curve.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var bezier = BABYLON.Curve3.CreateQuadraticBezier(origin, control, destination, nb_of_points);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to the Quadratic Bezier Curve.</p>
<ul class="list">
<li><p><b>Origin</b> &minus; Origin point for the curve.</p></li>
<li><p><b>Control</b> &minus; Control points for the curve.</p></li>
<li><p><b>Destination</b> &minus; Destination point.</p></li>
<li><p><b>Noofpoints</b> &minus; Points in array.</p></li>
</ul>
<h2>Cubic Bezeir Curve</h2>
<p>In this section, we will learn about the Cubic Bezier Curve.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var bezier3 = BABYLON.Curve3.CreateCubicBezier(origin, control1, control2, destination, nb_of_points)
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to the Cubic Bezier Curve.</p>
<ul class="list">
<li><p><b>Origin</b> &minus; Origin point.</p></li>
<li><p><b>control1</b> &minus; First control point in vector form.</p></li>
<li><p><b>control2</b> &minus; Second control point in vector form.</p></li>
<li><p><b>Destination</b> &minus; Destination point in vector form.</p></li>
<li><p><b>no_of_points</b> &minus; Numberof points in array form.</p></li>
</ul>
<h2>HermiteSpline Curve</h2>
<p>In this section, we will learn about the Hermite Spline Curve.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var hermite = BABYLON.Curve3.CreateHermiteSpline(p1, t1, p2, t2, nbPoints);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to the Hermite Spline Curve &minus;</p>
<ul class="list">
<li><p><b>p1</b> &minus; Origin point for the curve.</p></li>
<li><p><b>t1</b> &minus; Origin tangent vector point.</p></li>
<li><p><b>p2</b> &minus; Destination point.</p></li>
<li><p><b>t2</b> &minus; Destination tangent vector.</p></li>
<li><p><b>NbPoints</b> &minus; Array of points for the final curve.</p></li>
</ul>
<h2>Catmull-Rom Spline Curve</h2>
<p>In this section, we will learn about the Catmull-Rom Spline Curve.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
var nbPoints = 20;   // the number of points between each Vector3 control points
var points = [vec1, vec2, ..., vecN];  // an array of Vector3 the curve must pass through : the control points
var catmullRom = BABYLON.Curve3.CreateCatmullRomSpline(points, nbPoints);
</pre>
<h3>Parameters</h3>
<p>Consider the following parameters related to the Catmull-Rom Spline Curve &minus;</p>
<ul class="list">
<li><p><b>Points</b> &minus; An array of Vector3, the curve must pass through the control points.</p></li>
<li><p><b>NbPoints</b> &minus; The number of points between each Vector3 control points.</p></li>
</ul>
<pre class="result notranslate">
var path = catmullRom.getPoints(); // getPoints() returns an array of successive Vector3.
var l = catmullRom.length(); // method returns the curve length.
</pre>
<h3>Demo</h3>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3( .5, .5, .5);

            // camera
            var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -100));
            camera.attachControl(canvas, true);
            
            // lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            light.intensity = 0.8;
            var spot = new BABYLON.SpotLight(
            "spot", 
            new BABYLON.Vector3(25, 15, -10), 
            new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
            spot.diffuse = new BABYLON.Color3(1, 1, 1);
            spot.specular = new BABYLON.Color3(0, 0, 0);
            spot.intensity = 0.2; 
            
            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            
            //mat.wireframe = true;
            var makeTextPlane = function(text, color, size) {
               var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
               dynamicTexture.hasAlpha = true;
               dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
               
               var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
               
               plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
               plane.material.backFaceCulling = false;
               plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
               plane.material.diffuseTexture = dynamicTexture;
               return plane;
            };
            
            // show axis
            var showAxis = function(size) { 
               var axisX = BABYLON.Mesh.CreateLines("axisX", [ 
                  new BABYLON.Vector3(-size * 0.95, 0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0), 
                  new BABYLON.Vector3(-size * 0.95, -0.05 * size, 0),
                  new BABYLON.Vector3(-size, 0, 0),
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, 0.05 * size, 0), 
                  new BABYLON.Vector3(size, 0, 0), 
                  new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
               ], scene);
               
               axisX.color = new BABYLON.Color3(1, 0, 0);
               var xChar = makeTextPlane("X", "red", size / 10);
               xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);			
               
               var xChar1 = makeTextPlane("-X", "red", size / 10);
               xChar1.position = new BABYLON.Vector3(-0.9 * size, 0.05 * size, 0);
               
               var xcor = [];
               for (i =- 20; i &lt;= 20; i++) {
                  xcor[i] = makeTextPlane(i, "red", size / 10);
                  xcor[i].position = new BABYLON.Vector3(i, 0, 0);
               }
               
               var axisY = BABYLON.Mesh.CreateLines("axisY", [
                  new BABYLON.Vector3( -0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3(0.05 * size, -size * 0.95, 0),
                  new BABYLON.Vector3(0, -size, 0),
                  new BABYLON.Vector3.Zero(),
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( -0.05 * size, size * 0.95, 0), 
                  new BABYLON.Vector3(0, size, 0), 
                  new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
               ], scene);
               
               axisY.color = new BABYLON.Color3(0, 1, 0);
               var yChar = makeTextPlane("Y", "green", size / 10);
               yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
               var yChar1 = makeTextPlane("-Y", "green", size / 10);
               yChar1.position = new BABYLON.Vector3(0, -0.9 * size, 0.05 * size);
               var ycor = [];
               for (y =- 20; y &lt;= 20; y++) {
                  xcor[y] = makeTextPlane(y, "green", size / 10);
                  xcor[y].position = new BABYLON.Vector3(0, y, 0);
               }


               var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                  new BABYLON.Vector3( 0 , -0.05 * size, -size * 0.95), 
                  new BABYLON.Vector3(0, 0, -size),
                  new BABYLON.Vector3( 0 , 0.05 * size, -size * 0.95),
                  new BABYLON.Vector3(0, 0, -size), 
                  new BABYLON.Vector3.Zero(), 
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
                  new BABYLON.Vector3(0, 0, size), 
                  new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
               ], scene);
               axisZ.color = new BABYLON.Color3(0, 0, 1);
               var zChar = makeTextPlane("Z", "blue", size / 10);
               zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
               var zChar1 = makeTextPlane("-Z", "blue", size / 10);
               zChar1.position = new BABYLON.Vector3(0, 0.05 * size, -0.9 * size);

               var zcor = [];
               for (z =- 20; z &lt;= 20; z++) {
                  xcor[z] = makeTextPlane(z, "green", size / 10);
                  xcor[z].position = new BABYLON.Vector3(0, 0, z);
               }
            };

            var quadraticBezierVectors = BABYLON.Curve3.CreateQuadraticBezier( 
            BABYLON.Vector3.Zero(), 
            new BABYLON.Vector3(10, 5, 5), 
            new BABYLON.Vector3(5, 10, 0), 15);
            var quadraticBezierCurve = BABYLON.Mesh.CreateLines("qbezier", quadraticBezierVectors.getPoints(), scene);
            quadraticBezierCurve.color = new BABYLON.Color3(1, 1, 0.5);

            var cubicBezierVectors = BABYLON.Curve3.CreateCubicBezier( 
            BABYLON.Vector3.Zero(), 
            new BABYLON.Vector3(10, 5, 20), 
            new BABYLON.Vector3(-50, 5, -20), 
            new BABYLON.Vector3( -10, 20, 10), 60);
            var cubicBezierCurve = BABYLON.Mesh.CreateLines("cbezier", cubicBezierVectors.getPoints(), scene);
            cubicBezierCurve.color = new BABYLON.Color3(1, 0, 0);

            var continued = cubicBezierVectors.continue(cubicBezierVectors).continue(quadraticBezierVectors);

            var points = continued.getPoints();
            var nbPoints = 60;
            var l = continued.length() / 2;
            var p1 = points[points.length - 1];
            var t1 = (p1.subtract(points[points.length - 2])).scale(l);
            var p2 = points[0];
            var t2 = (points[1].subtract(p2)).scale(l);

            var hermite = BABYLON.Curve3.CreateHermiteSpline(p1, t1, p2, t2, nbPoints);

            continued = continued.continue(hermite);

            var points = continued.getPoints();
            var continuedCurve = BABYLON.Mesh.CreateLines("continued", points, scene);
            continuedCurve.position = new BABYLON.Vector3(20, -20, 20);
            continuedCurve.color = new BABYLON.Color3(0, 0, 0);

            var nbPoints = 20;                     // the number of points between each Vector3 control points
            var points = [new BABYLON.Vector3(10, 5, 20), 
            new BABYLON.Vector3(-20, 5, -20), 
            new BABYLON.Vector3(-25, 5, -20), 
            new BABYLON.Vector3( -30, 20, 10),];  // an array of Vector3 the curve must pass through : the control points
            var catmullRom = BABYLON.Curve3.CreateCatmullRomSpline(points, nbPoints);

            var path = catmullRom.getPoints();
            var l = catmullRom.length();

            var finalcatmullCurve = BABYLON.Mesh.CreateLines("continued", path, scene);

            var mySinus = [];
            for (var i = 0; i &lt; 30; i++) {
               mySinus.push( new BABYLON.Vector3(i, Math.sin(i / 10), 0) );
            }

            var mySinusCurve3 = new BABYLON.Curve3(mySinus);
            var myFullCurve = mySinusCurve3.continue(cubicBezierVectors).continue(quadraticBezierVectors);
            var points1 = myFullCurve.getPoints();
            var curve3d = BABYLON.Mesh.CreateLines("continued", points1, scene);
            curve3d.color = new BABYLON.Color3(0.9, 1, 0.2);
            showAxis(20);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h3>Output</h3>
<p>The above line of code will generate the following output &minus;</p>
<img src="/babylonjs/images/catmull_rom_spline_curve.jpg" alt="Catmull-Rom Spline Curve" />
<h1>BabylonJS - Dynamic Texture</h1>
<p>The Dynamic Texture of BabylonJS creates a canvas and you can easily write text on the texture. It also allows you to work with canvas and use all the features available with html5 canvas to be used with dynamic texture.</p>
<p>We will work on an example, which will show how to write text on the texture and will also draw a bezier Curve on the mesh we create.</p>
<h2>Syntax</h2> 
<p>Following is the syntax to create Dynamic texture &minus;</p>
<pre class="result notranslate">
var myDynamicTexture = new BABYLON.DynamicTexture(name, option, scene);
</pre>
<h2>Parameters</h2>
<p>Following are the required parameters to create dynamic texture &minus;</p>
<ul class="list">
<li><p><b>name</b> &minus; name of the dynamic texture</p></li>
<li><p><b>option</b> &minus; will have the width and height of the dynamic texture</p></li>
<li><p><b>scene</b> &minus; scene created</p></li>
</ul>
<h2>Syntax</h2> 
<p>Following is the syntax to write text on the texture &minus;</p>
<pre class="result notranslate">
myDynamicTexture.drawText(text, x, y, font, color, canvas color, invertY, update);
</pre>
<h2>Parameters</h2>
<p>Following are the required parameters to write text on the texture &minus;</p>
<ul class="list">
<li><p><b>text</b> &minus; text to be written;</p></li>
<li><p><b>x</b> &minus; distance from the left-hand edge;</p></li>
<li><p><b>Y</b> &minus; distance from the top or bottom edge, depending on invertY;</p></li>
<li><p><b>font</b> &minus; font definition in the form font-style, font-size, font_name;</p></li>
<li><p><b>invertY</b> &minus; true by default in which case y is the distance from the top, when false, y is distance from the bottom and the letters reversed;</p></li>
<li><p><b>update</b> &minus; true by default, the dynamic texture will immediately be updated.</p></li>
</ul>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;MDN Games: Babylon.js demo - shapes&lt;/title&gt;
      &lt;script src = "https://end3r.github.io/MDN-Games-3D/Babylon.js/js/babylon.js"&gt;&lt;/script&gt;    
      &lt;style&gt;
         html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI/2, Math.PI / 3, 25, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;	

            var box = BABYLON.Mesh.CreateBox("box", 3.0, scene);
            box.position = new BABYLON.Vector3(0, 0, -5); 

            //Create dynamic texture		
            var textureGround = new BABYLON.DynamicTexture("dynamic texture", {width:512, height:256}, scene);   
            var textureContext = textureGround.getContext();

            var materialGround = new BABYLON.StandardMaterial("Mat", scene);    				
            materialGround.diffuseTexture = textureGround;
            box.material = materialGround;

            //Add text to dynamic texture
            var font = "bold 60px Arial";
            textureGround.drawText("Box", 200, 150, font, "green", "white", true, true);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<img src="/babylonjs/images/dynamic_texture.jpg" alt="Dynamic Texture" />
<p>Dynamic texture also allows to work with html5 canvas methods and properties on dynamic texture as follows &minus;</p>
<h2>Syntax</h2>
<pre class="result notranslate">
var ctx = myDynamicTexture.getContext();
</pre>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt; Babylon.JS : Demo2&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;   
      &lt;style&gt;
         canvas { width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);	
         var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI/2, Math.PI / 3, 25, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;		

            var ground = BABYLON.MeshBuilder.CreateGround("ground1", {width: 20, height: 10, subdivisions: 25}, scene);

            //Create dynamic texture
            var textureGround = new BABYLON.DynamicTexture("dynamic texture", 512, scene);   
            var textureContext = textureGround.getContext();

            var materialGround = new BABYLON.StandardMaterial("Mat", scene);    				
            materialGround.diffuseTexture = textureGround;
            ground.material = materialGround;

            //Draw on canvas
            textureContext.beginPath();
            textureContext.moveTo(75,40);
            textureContext.bezierCurveTo(75,37,70,25,50,25);
            textureContext.bezierCurveTo(20,25,20,62.5,20,62.5);
            textureContext.bezierCurveTo(20,80,40,102,75,120);
            textureContext.bezierCurveTo(110,102,130,80,130,62.5);
            textureContext.bezierCurveTo(130,62.5,130,25,100,25);
            textureContext.bezierCurveTo(85,25,75,37,75,40);
            textureContext.fillStyle = "red";
            textureContext.fill();
            textureGround.update();
            
            return scene;
         };
         var scene = createScene();
            engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<img src="/babylonjs/images/dynamic_texture1.jpg" alt="Dynamic Texture1" />
<h2>Explanation</h2>
<p>We have created ground mesh and added dynamic texture to it.</p>
<pre class="prettyprint notranslate">
//ground mesh
var ground = BABYLON.MeshBuilder.CreateGround("ground1", {width: 20, height: 10, subdivisions: 25}, scene);

//Create dynamic texture
var textureGround = new BABYLON.DynamicTexture("dynamic texture", 512, scene);   

//adding dynamic texture to ground using standard material
var materialGround = new BABYLON.StandardMaterial("Mat", scene);    			
materialGround.diffuseTexture = textureGround;
ground.material = materialGround;
</pre>
<p>To work with canvas on dynamic texture, we need to call canvas method first &minus;</p>
<pre class="result notranslate">
var textureContext = textureGround.getContext()
</pre>
<p>To the canvas, we will add the bezierCurve as follows &minus;</p>
<pre class="prettyprint notranslate">
textureContext.beginPath();
textureContext.moveTo(75,40);

textureContext.bezierCurveTo(75,37,70,25,50,25);
textureContext.bezierCurveTo(20,25,20,62.5,20,62.5);
textureContext.bezierCurveTo(20,80,40,102,75,120);
textureContext.bezierCurveTo(110,102,130,80,130,62.5);
textureContext.bezierCurveTo(130,62.5,130,25,100,25);
textureContext.bezierCurveTo(85,25,75,37,75,40);

textureContext.fillStyle = "red";
textureContext.fill();
textureGround.update();
</pre>
<h1>BabylonJS - Parallax Mapping</h1>
<p>Parallax mapping is also called offset mapping. It uses a height map which is applied as an offset on the material's textures in order to accentuate the effect of relief in the geometry's surface. In the 3Dworld, stone walls with a depth applied to it will have more apparent looks and will look realistic to the end user. At steeper view-angles, the texture coordinates are displaced more, giving the illusion of depth due to parallax effects as the view changes.</p>
<p>Parallex mapping is used with standard material. We learnt about this in the standard material chapter.</p>
<p>There are 3 properties which are present with parallex mapping.</p>
<ul class="list">
<li><p><b>material.useParallax = true;</b> &minus; This enables the parallex mapping. To use this property you need assign bump texture to the material first.</p></li>
<li><p><b>material.useParallaxOcclusion = true;</b> &minus; To use this property, you have to set useParallax to true. It enables Parallax Occlusion.</p></li>
<li><p><b>material.parallaxScaleBias = 0.1;</b> &minus; Applies a scaling factor for the depth to be as singed to the mesh.A value between .05 and .1 is fine for Parallax. For occlusion, you can reach 0.2.</p></li>
</ul>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            // This creates and positions a free camera (non-mesh)
            var camera = new BABYLON.ArcRotateCamera("camera1", 0, Math.PI / 2, 100, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, false);

            // This targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());

            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;

            var mesh = BABYLON.Mesh.CreateBox("box01", 25, scene);
            mesh.position = new BABYLON.Vector3(0, 0, 0);

            var brickWallDiffURL = "images/a1.png";
            var brickWallNHURL = "images/a2.png";
            var stoneDiffURL = "images/pebble.jpg";
            var stoneNHURL = "images/a3.png";

            var stoneDiffuseTexture = new BABYLON.Texture(stoneDiffURL, scene);
            
            var stoneNormalsHeightTexture = new BABYLON.Texture(stoneNHURL, scene);
            
            var wallDiffuseTexture = new BABYLON.Texture(brickWallDiffURL, scene);
            
            var wallNormalsHeightTexture = new BABYLON.Texture(brickWallNHURL, scene);
            
            var normalsHeightTexture = stoneNormalsHeightTexture;

            var material = new BABYLON.StandardMaterial("mtl01", scene);
            material.diffuseTexture = stoneDiffuseTexture;
            material.bumpTexture = stoneNormalsHeightTexture;
            
            material.useParallax = true;
            material.useParallaxOcclusion = true;
            material.parallaxScaleBias = 0.1;
            material.specularPower = 1000.0;
            material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            mesh.material = material;	
            return scene;		
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code will generate the following output &minus;</p>
<img src="/babylonjs/images/parallex_mapping.jpg" alt="Parallex Mapping" />
<p>In this demo, we have used images <b>a1.png, a2.png, pebble.jpg</b> and <b>a3.png</b>. The images are stored in images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<h3>Images/a1.png</h3>
<img src="/babylonjs/images/a1_wall.jpg" alt="A1 Wall" />
<h3>Images/a2.png</h3>
<img src="/babylonjs/images/a2_wall.jpg" alt="A2 Wall" />
<h3>Images/pebble.jpg</h3>
<img src="/babylonjs/images/pebble.jpg" alt="A1 Wall" />
<h3>images/a3.png</h3>
<img src="/babylonjs/images/a3_wall.jpg" alt="A3 Wall" />
<h1>BabylonJS - Lens Flares</h1>
<p>When light is scattered and falls on the image, you get to see a different image in terms of looks and the color changes too. When you develop a game to show a realistic occurrence of the light effect, lens flare is used. Consider sun rays falling on the mirror and the effect seen of it is mostly called Lens Flare.</p>
<h2>Syntax</h2> 
<p>Following is the syntax to create lens flare &minus;</p>
<pre class="result notranslate">
var lensFlareSystem = new BABYLON.LensFlareSystem("lensFlareSystem", light0, scene);
</pre>
<h2>Parameters</h2>
<p>Consider the following parameters to create lens flare &minus;</p>
<ul class="list">
<li><p><b>Name</b> &minus; Name given to the lensflaresystem.</p></li>
<li><p><b>Light</b> &minus; This can be light source or camera.</p></li>
<li><p><b>Scene</b> &minus; Scene to which the lens flare will be added.</p></li>
</ul>
<p>To add flares to the scene, execute the following command &minus;</p>
<pre class="result notranslate">
var flare1 = new BABYLON.LensFlare(0.5, 0.15, new BABYLON.Color3(1, 1, 1), "images/sun1.png", lensFlareSystem);
</pre>
<ul class="list">
<li><p><b>Size</b> &minus; Floating value between 0 and 1.</p></li>
<li><p><b>Position</b> &minus; The source (the emitter) of the lens flares (it can be a camera, a light or a mesh).</p></li>
<li><p><b>Lensflaresystem</b> &minus; Object created using lensflaresystem class.</p></li>
</ul>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = BABYLON.Color3.Gray();
            var camera = new BABYLON.ArcRotateCamera(
               "Camera", -Math.PI / 2, 1.5, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, false);

            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, -1, 0), scene);
            light1.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            light1.intensity = 0.5;
            
            var bigdiamond = BABYLON.Mesh.CreateSphere("sphere", 32,6, scene);
            bigdiamond.visibility = 0.6;
            var dmat = new BABYLON.StandardMaterial("dmat", scene);
            dmat.diffuseColor = BABYLON.Color3.Blue();
            
            var texture = new BABYLON.Texture("images/earth.jpg", scene);
            dmat.diffuseTexture = texture;		
            dmat.specularColor = BABYLON.Color3.White();
            bigdiamond.material = dmat;

            var lensflare1 = new BABYLON.LensFlareSystem("lensFlareSystem", camera, scene);
            var flare1 = new BABYLON.LensFlare(
               Math.random(), 0.15, new BABYLON.Color3(1, 1, 1), "images/sun1.png", lensflare1);

            var lensflare2 = new BABYLON.LensFlareSystem("lensFlareSystem", camera, scene);
            var flare2 = new BABYLON.LensFlare(
               Math.random()/2, 0.1, new BABYLON.Color3(1, 0, 0), "images/sun1.png", lensflare2);

            var lensflare3 = new BABYLON.LensFlareSystem("lensFlareSystem", camera, scene);
            var flare3 = new BABYLON.LensFlare(
               Math.random()/8, 0.1, new BABYLON.Color3(1, 0, 1), "images/sun1.png", lensflare3);

            var lensflare4 = new BABYLON.LensFlareSystem("lensFlareSystem", camera, scene);
            var flare4 = new BABYLON.LensFlare(
               Math.random()/12, 0.1, new BABYLON.Color3(0, 1, 0), "images/sun1.png", lensflare4);

            scene.registerBeforeRender(function() {
               scene.getCameraByID("Camera").alpha += 0.01;
            });		
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/lens_flares.jpg" alt="Lens Flares" />
<h3>earth.jpg</h3>
<img src="/babylonjs/images/earth.jpg" alt="earth" />
<h3>images/sun1.png</h3>
<img src="/babylonjs/images/sun1.jpg" alt="sun1" />
<h1>BabylonJS - Create ScreenShot</h1>
<p>To capture the screen on which you are presently working, it is not possible to take screenshot with high resolution using the print screen keypress. BabylonJS provides createscreenshot APIwhich helps to do so. It saves the file as png format and the quality of the image is not sacrified.</p>
<h2>Syntax</h2>
<p>To take screenshot of the screen we need to provide engine, camera and the size as shown below.</p>
<pre class="result notranslate">
BABYLON.Tools.CreateScreenshot(engine, camera, { width: 1024, height: 300 }, function (data) {
   var img = document.createElement("img");
   img.src = data;
   document.body.appendChild(img);	
});
</pre>
<p>A button that calls the screenshot API, when a user clicks it, is put.</p>
<p>Changes are made to the engine which is passed to the screenshot api.</p>
<pre class="result notranslate">
var engine = new BABYLON.Engine(canvas, true, { 
   preserveDrawingBuffer: true, stencil: true 
});	
</pre>
<p>It requires options like <b>preserveDrawingBuffer</b> and <b>stencil</b> set to true.</p>
<p>Button is added as follows &minus;</p>
<pre class="result notranslate">
ssButton = document.createElement("input");
document.body.appendChild (ssButton);
</pre>
<p>Click event is added to the button above and the <b>createscreenshot</b> is called. It will update the screenshot at the end of the screen. The data used for image src has the screenshot url created.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });	
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            
            // Setup environment
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.5, 0), scene);
            
            var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 1, 0.8, 20, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var gmat = new BABYLON.StandardMaterial("mat1", scene);
            gmat.alpha = 1.0;
            
            //gmat.diffuseColor = new BABYLON.Color3(1, 0, 0);
            var texture = new BABYLON.Texture("images/mat.jpg", scene);
            gmat.diffuseTexture = texture;

            var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 150, height:15}, scene);
            ground.material = gmat;

            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(1, 0, 0);
            
            var texture = new BABYLON.Texture("images/rugby.jpg", scene);
            mat.diffuseTexture = texture;

            var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, diameterX: 3}, scene);
            sphere.position= new BABYLON.Vector3(15,1,0);
            sphere.material = mat;

            var faceColors = new Array();
            faceColors[1] = new BABYLON.Color4(0,1,0,1);   // green front

            var matcone = new BABYLON.StandardMaterial("mat1", scene);
            matcone.alpha = 1.0;
            matcone.diffuseColor = new BABYLON.Color3(0.9, 0, 2);
            
            var texture = new BABYLON.Texture("images/cone.jpg", scene);
            matcone.diffuseTexture = texture;

            var cone = BABYLON.MeshBuilder.CreateCylinder("cone", {diameterTop: 0, tessellation: 4}, scene);
            cone.position= new BABYLON.Vector3(12,1,0);
            cone.material = matcone;

            var matplane = new BABYLON.StandardMaterial("matplane", scene);
            matplane.alpha = 1.0;
            matplane.diffuseColor = new BABYLON.Color3(0.9, 0, 2);
            
            var texture = new BABYLON.Texture("images/board.jpg", scene);
            matplane.diffuseTexture = texture;
            var plane = BABYLON.MeshBuilder.CreatePlane("plane", {width: 5, height : 5}, scene);
            plane.position= new BABYLON.Vector3(9,2.5,0);
            plane.material = matplane;		
            
            var disc = BABYLON.MeshBuilder.CreateDisc("disc", {tessellation: 3}, scene);
            disc.position= new BABYLON.Vector3(5,1,0);		

            var mattorus = new BABYLON.StandardMaterial("matoct", scene);
            mattorus.alpha = 1.0;
            
            var texture = new BABYLON.Texture("images/ring.jpg", scene);
            mattorus.diffuseTexture = texture;
            
            var torus = BABYLON.MeshBuilder.CreateTorus("torus", {thickness: 0.5}, scene);		
            torus.position= new BABYLON.Vector3(3,1,0);
            torus.material = mattorus;

            var matoct = new BABYLON.StandardMaterial("matoct", scene);
            matoct.alpha = 1.0;
            
            var texture = new BABYLON.Texture("images/d1.png", scene);
            matoct.diffuseTexture = texture;
            var octahedron = BABYLON.MeshBuilder.CreatePolyhedron("oct", {type: 1, size: 3}, scene);
            
            octahedron.position= new BABYLON.Vector3(-2,5,0);
            octahedron.material = matoct;	

            var matico = new BABYLON.StandardMaterial("matico", scene);
            matico.alpha = 1.0;
            
            var texture = new BABYLON.Texture("images/diamond.jpg", scene);
            matico.diffuseTexture = texture;		
            
            var icosphere = BABYLON.MeshBuilder.CreateIcoSphere("ico", {radius: 5, radiusY: 3, subdivisions: 2}, scene);
            icosphere.position= new BABYLON.Vector3(-13,3,0);		
            icosphere.material = matico;		
            
            //add screenshot button
            var ssButton = document.getElementById("takescreenshot");
            if (ssButton == null) {
               ssButton = document.createElement("input");
               document.body.appendChild(ssButton);
            }
            
            ssButton.id = "takescreenshot";
            ssButton.type = "button";
            ssButton.style.position = "fixed";
            ssButton.style.right = "0px";
            ssButton.style.top = "100px";
            ssButton.value = "create screenshot";
            
            ssButton.onclick = function () {
               BABYLON.Tools.CreateScreenshot(engine, camera, { width: 1024, height: 300 },
               function (data) {
                  var img = document.createElement("img");
                  img.src = data;
                  document.body.appendChild(img);
               });
            };			
            return scene;
         }
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });	
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>	
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/create_screenshot.jpg" src="Create Screenshot" />
<p>In this demo, we have used images <b>mat.jpg, rugby.jpg, cone.jpg, board.jpg, ring.jpg, d1.png, diamond.jpg</b>. The images are stored in the images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<h3>Images/mat.jpg</h3>
<img src="/babylonjs/images/mat_image.jpg" alt="Mat Image" />
<h3>Images/rugby.jpg</h3>
<img src="/babylonjs/images/rugby_image.jpg" alt="rugby Image" />
<h3>Images/cone.jpg</h3>
<img src="/babylonjs/images/cone_image.jpg" alt="Cone Image" />
<h3>Images/board.jpg</h3>
<img src="/babylonjs/images/board_image.jpg" alt="Board Image" />
<h3>Images/ring.jpg</h3>
<img src="/babylonjs/images/ring_image.jpg" alt="Ring Image" />
<h3>Images/d1.png</h3>
<img src="/babylonjs/images/d1_image.jpg" alt="D1 Image" />
<h3>Images/diamond.jpg</h3>
<img src="/babylonjs/images/diamond_image.jpg" alt="Diamond Image" />
<h1>BabylonJS - Reflection Probes</h1>
<p>Reflection probes are used to create a mirror like scene. This helps in seeing the reflection of the meshes in it. To create a mirror like scene, you need to call the class and the required meshes wherein you want to see reflection. Later, you need to add the meshes to the renderlist as shown below. Consider you have skybox with water surface and you need to show the clouds or tree reflection or the bird flying in the water, you can do so using reflection probe and the meshes created can be added to the renderlist as shown below.</p>
<h2>Syntax</h2>
<pre class="result notranslate">
var probe = new BABYLON.ReflectionProbe("main", 512, scene);
probe.renderList.push(yellowSphere);
probe.renderList.push(greenSphere);	
probe.renderList.push(blueSphere);	
probe.renderList.push(mirror);
</pre>	
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 10, BABYLON.Vector3.Zero(), scene);

            camera.setPosition(new BABYLON.Vector3(0, 5, -10));
            camera.attachControl(canvas, true);

            camera.upperBetaLimit = Math.PI / 2;
            camera.lowerRadiusLimit = 4;

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            var knot = BABYLON.Mesh.CreateTorusKnot("knot", 1, 0.4, 128, 64, 2, 3, scene);

            var yellowSphere = BABYLON.Mesh.CreateSphere("yellowSphere", 16, 1.5, scene);
            yellowSphere.setPivotMatrix(BABYLON.Matrix.Translation(3, 0, 0));

            var blueSphere = BABYLON.Mesh.CreateSphere("blueSphere", 16, 1.5, scene);
            blueSphere.setPivotMatrix(BABYLON.Matrix.Translation(-1, 3, 0));

            var greenSphere = BABYLON.Mesh.CreateSphere("greenSphere", 16, 1.5, scene);
            greenSphere.setPivotMatrix(BABYLON.Matrix.Translation(0, 0, 3));

            // Mirror
            var mirror = BABYLON.Mesh.CreateBox("Mirror", 1.0, scene);
            mirror.scaling = new BABYLON.Vector3(100.0, 0.01, 100.0);
            mirror.material = new BABYLON.StandardMaterial("mirror", scene);
            mirror.material.diffuseTexture = new BABYLON.Texture("images/square.jpg", scene);
            
            mirror.material.diffuseTexture.uScale = 10;
            mirror.material.diffuseTexture.vScale = 10;
            mirror.material.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
            
            mirror.material.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, -1.0, 0, -2.0);
            mirror.material.reflectionTexture.renderList = [greenSphere, yellowSphere, blueSphere, knot];
            mirror.material.reflectionTexture.level = 0.5;
            mirror.position = new BABYLON.Vector3(0, -2, 0);	

            // Main material	
            var mainMaterial = new BABYLON.StandardMaterial("main", scene);
            knot.material = mainMaterial;

            var probe = new BABYLON.ReflectionProbe("main", 512, scene);
            probe.renderList.push(yellowSphere);
            probe.renderList.push(greenSphere);	
            probe.renderList.push(blueSphere);	
            probe.renderList.push(mirror);	
            
            mainMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0.5);	
            mainMaterial.reflectionTexture = probe.cubeTexture;
            mainMaterial.reflectionFresnel&lt;h3&gt;Parameters&lt;/h3&gt; = new BABYLON.Fresnel&lt;h3&gt;Parameters&lt;/h3&gt;();
            mainMaterial.reflectionFresnel&lt;h3&gt;Parameters&lt;/h3&gt;.bias = 0.02;

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
            scene.fogColor = scene.clearColor;
            scene.fogStart = 20.0;
            scene.fogEnd = 50.0;

            // Animations
            scene.registerBeforeRender(function () {
               yellowSphere.rotation.y += 0.01;
               greenSphere.rotation.y += 0.01;
               blueSphere.rotation.y += 0.01;
            });
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<img src="/babylonjs/images/reflection_probes.jpg" alt="Reflection Probes" />
<p>In this demo, we have used image <b>square.jpg</b>. The images are stored in the images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<h3>images/square.jpg</h3>
<img src="/babylonjs/images/square.jpg" alt="square" />
<h1>BabylonJS - Standard Rendering Pipeline</h1>
<p>StandardRenderingPipeline comes up with a set of postprocess effects which relate to the real world. There are different post process effects such as light effect and illumination effect.</p>
<p>In the example given below, you will see various effects like lens effect, post process effect of lights, etc.</p>
<p>It uses an HDR cube texture and the texture has to be .hdr. This texture gives a panaromic effect which can be seen while you rotate the camera.</p>
<pre class="result notranslate">
var hdrTexture = new BABYLON.HDRCubeTexture("images/GravelPlaza_REF.hdr", scene, 512);
</pre>
<p>Standard rendering pipeline class is called to get the effect with the following line of code &minus;</p>
<pre class="result notranslate">
// Create rendering pipeline
var pipeline = new BABYLON.StandardRenderingPipeline("standard", scene, 1.0 / devicePixelRatio, null, [camera]);
pipeline.lensTexture = new BABYLON.Texture("images/lensdirt.jpg", scene)
</pre>
<p>In the demo shown below, we will create the cubetexture environment. We will use ground mesh for the same and apply standard rendering pipeline to the whole scene.</p>
<p>The texture is given to it using lensTexture which is an image and you can see the same texture as you move the scene.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 4, Math.PI / 2.5, 200, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.minZ = 0.1;

            // Light
            new BABYLON.PointLight("point", new BABYLON.Vector3(0, 40, 0), scene);

            // Environment Texture
            var hdrTexture = new BABYLON.HDRCubeTexture("images/GravelPlaza_REF.hdr", scene, 512);

            // Skybox
            var hdrSkybox = BABYLON.Mesh.CreateBox("hdrSkyBox", 1000.0, scene);
            var hdrSkyboxMaterial = new BABYLON.PBRMaterial("skyBox", scene);
            hdrSkyboxMaterial.backFaceCulling = false;
            hdrSkyboxMaterial.reflectionTexture = hdrTexture.clone();
            hdrSkyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            hdrSkyboxMaterial.microSurface = 1.0;
            hdrSkyboxMaterial.cameraExposure = 0.6;
            hdrSkyboxMaterial.cameraContrast = 1.6;
            hdrSkyboxMaterial.disableLighting = true;
            hdrSkybox.material = hdrSkyboxMaterial;
            hdrSkybox.infiniteDistance = true;

            // Create mesh
            var woodbox = BABYLON.MeshBuilder.CreateBox("plane", { 
               width: 40, 
               height: 50, 
               depth: 65 
            }, scene);

            var wood = new BABYLON.PBRMaterial("wood", scene);
            wood.reflectionTexture = hdrTexture;
            wood.directIntensity = 1.5;
            wood.environmentIntensity = 0.5;
            wood.specularIntensity = 0.3;
            wood.cameraExposure = 0.9;
            wood.cameraContrast = 1.6;

            wood.reflectivityTexture = new BABYLON.Texture("images/reflectivity.png", scene);
            wood.useMicroSurfaceFromReflectivityMapAlpha = true;

            wood.albedoColor = BABYLON.Color3.White();
            wood.albedoTexture = new BABYLON.Texture("images/albedo.png", scene);
            woodbox.material = wood;

            // Create rendering pipeline
            var pipeline = new BABYLON.StandardRenderingPipeline("standard", scene, 1.0 / devicePixelRatio, null, [camera]);
            pipeline.lensTexture = new BABYLON.Texture("images/lensdirt.jpg", scene);

            // Return scene
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Create images folder and store the .hdr file in it. We have used images/GravelPlaza_REF.hdr from <a href="http://www.hdrlabs.com/sibl/archive.html" target="_blank" rel="nofollow">www.hdrlabs.com</a>.</p>
<p>You can downwload  .hdr type files of your choice and use in the demo link.</p>
<h2>Output</h2>
<p>The above line of code will generate the following output &minus;</p>
<img src="/babylonjs/images/standard_rendering_pipeline.jpg" alt="Standard Rendering Pipeline" />
<p>In this demo, we have used images <b>images/GravelPlaza_REF.hdr, images/reflectivity.png, images/albedo.png, images/lensdirt.jpg</b>. The images are stored in images/ folder locally and are also pasted below for reference. You can download any images of your choice and use in the demo link. Please note it is difficult to paste the .hdr files here as the size of it is very large.</p>
<h3>Images/reflectivity.png</h3>
<img src="/babylonjs/images/reflectivity.jpg" alt="Reflectivity" />
<h3>Images/albedo.png</h3>
<img src="/babylonjs/images/albedo.jpg" alt="Albedo" />
<h3>Images/lensdirt.png</h3>
<img src="/babylonjs/images/lens_dirt.jpg" alt="Lens Dirt" />
<h1>BabylonJS - ShaderMaterial</h1>
<p>Shader material gives you a material as an output. You can apply this material to any mesh. It basically passes the data from your scene to the vertex and fragment shaders.</p>
<p>To get the shader material, the following class is called &minus;</p>
<pre class="result notranslate">
var myShaderMaterial = new BABYLON.ShaderMaterial(name, scene, route, options);
</pre>
<h2>Parameters</h2>
<p>Consider the following parameters related to the shader material &minus;</p>
<ul class="list">
<li><p><b>Name</b> &minus; A string, naming the shader.</p></li>
<li><p><b>Scene</b> &minus; The scene in which the shader is to be used.</p></li>
<li><p><b>Route</b> &minus; The route to the shader code in one of the three ways &minus;</p></li>
</ul>
<pre class="result notranslate">
object - {
   vertex: "custom", 
   fragment: "custom" 
}, used with 
BABYLON.Effect.ShadersStore["customVertexShader"] and
BABYLON.Effect.ShadersStore["customFragmentShader"]
</pre>
<p></p>
<pre class="result notranslate">
object - { 
   vertexElement: "vertexShaderCode", 
   fragmentElement: "fragmentShaderCode" 
}, 
used with shader code in &lt;script&gt; tags
</pre>
<p></p>
<pre class="result notranslate">
string - "./COMMON_NAME", 
</pre>
<p>The syntax mentioned in the end is used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in the index.html folder.</p>
<ul class="list">
<li><p><b>Options</b> &minus; object containing attributes and uniforms arrays containing their names as strings.</p></li>
</ul>
<p>The shader syntax with values look as shown below &minus;</p>
<pre class="result notranslate">
var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
   vertex: "custom",
   fragment: "custom",
},
{
   attributes: ["position", "normal", "uv"],
   uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"]
});
</pre>
<p>Attributes have to be in array form. These contain position, normal and uv which are vector3 3D floating point vectors.</p>
<ul class="list">
<li><p><b>vec2</b> &minus; A two-dimensional vector of floating-point numbers.</p></li>
<li><p><b>vec3</b> &minus; A three-dimensional vector of floating-point numbers.</p></li>
<li><p><b>mat4</b> &minus; A matrix with 4 columns and 4 rows floating-point numbers.</p></li>
<li><p><b>gl_Position</b> &minus; It provides positional data for screen coordinates.</p></li>
<li><p><b>gl_FragColor</b> &minus; It provides colour data for the representation of a facet on screen.</p></li>
</ul>
<p>The above are built in variables in GLSL language.</p>
<p>Since vertex positions need to be as accurate as possible, all floating-point numbers should be set as having high precision. This is done at the start of the code for each shader using – <b>precision highp float</b>. The precision highp float determines how much precision is used for a float.</p>
<p>The following demo is based on the first object method.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         //downloaded HDR files from :http://www.hdrlabs.com/sibl/archive.html
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera(
               "Camera", Math.PI / 4, Math.PI / 4, 4, BABYLON.Vector3.Zero(), scene);

            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

            BABYLON.Effect.ShadersStore["customVertexShader"] = "\r\n" + 
               "precision highp float;\r\n" + 
               "// Attributes\r\n" + 
               "attribute vec3 position;\r\n" + 
               "attribute vec2 uv;\r\n" + 
               "// Uniforms\r\n" + 
               "uniform mat4 worldViewProjection;\r\n" + 

               "// Varying\r\n" + 
               "varying vec2 vUV;\r\n" + 
               "void main(void) {
                  \r\n" + 
                  "gl_Position = worldViewProjection * vec4(position, 1.0);\r\n" + 
                  "vUV = uv;\r\n"+"
               }
               \r\n";
               BABYLON.Effect.ShadersStore["customFragmentShader"] = "\r\n"+
                  "precision highp float;\r\n" + 
                  "varying vec2 vUV;\r\n" + 
                  "uniform sampler2D textureSampler;\r\n" + 
               "void main(void) {
                  \r\n"+
                  "gl_FragColor = texture2D(textureSampler, vUV);\r\n"+"
               }
               \r\n";

            var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
               vertex: "custom",
               fragment: "custom",
            },
            
            {
               attributes: ["position", "normal", "uv"],
               uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"]
            });

            var mainTexture = new BABYLON.Texture("images/mat.jpg", scene);

            shaderMaterial.setTexture("textureSampler", mainTexture);

            shaderMaterial.backFaceCulling = false;

            var box = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
            box.material = shaderMaterial;
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code will generate the following output &minus;</p>
<img src="/babylonjs/images/shader_material.jpg" alt="Shader Material"/>
<p>In this demo, we have used image <b>mat.jpg</b>. The images are stored in the images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p>
<h3>Images/mat.jpg</h3>
<img src="/babylonjs/images/mat_image.jpg" alt="Mat Image"/>
<h1>BabylonJS - Bones and Skeletons</h1>
<p>Babylonjs offers APIs to create skeletons and bones.</p>
<h2>Syntax</h2>
<p>Let us now see the syntax for different functions.</p>
<h3>For Skeleton</h3>
<pre class="result notranslate">
BABYLON.Skeleton = function (name, id, scene)
</pre>
<h3>For Bone</h3>
<pre class="result notranslate">
BABYLON.Bone = function (name, skeleton, parentBone, matrix)
</pre>
<p><b>Skeletons and Bones</b> can be created using blender and the same can be exported in .babylonjs.</p>
<h2>Demo</h2> 
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Element-Creating Scene&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);

            //Adding a light
            var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(20, 20, 100), scene);

            //Adding an Arc Rotate Camera
            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0.8, 100, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, false);

            BABYLON.SceneLoader.ImportMesh(
               "him", "scenes/Dude/", "Dude.babylon", scene, function (newMeshes, particleSystems, skeletons) {
               var dude = newMeshes[0];
               console.log(dude);
               dude.rotation.y = Math.PI;
               dude.position = new BABYLON.Vector3(0, 0, -80);
               scene.beginAnimation(skeletons[0], 0, 100, true, 1.0);
            })
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>In the above demo link, we have used Dude.babylon mesh. You can download the json file for Dude.babylon from here &minus;</p>
<p><a href="https://github.com/BabylonJS/Website/tree/master/Scenes/Dude" target="_blank" rel="nofollow">Dude.babylon</a></p>  
<p>Save the file in scenes to get the output as shown below.</p>
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/skeletons_and_bones.jpg" alt="Skeletons And Bones" />
<h2>Explanation</h2>
<p>For the import mesh, we have used babylonjs dude mesh.</p>
<p>The mesh gives us skeletons. For example, skeleton = skeletons[0];</p>
<p>To get bones from the skeletons, execute the following command &minus;</p>
<pre class="result notranslate">
skeleton.bones; //it gives a array.
</pre>
<p>In the above demo, we created 2 spheres and passed on to the mesh. For this, we executed the following commands &minus;</p>
<pre class="result notranslate">
sphere.attachToBone(skeleton.bones[30], dude);
</pre>
<p>And,</p>
<pre class="result notranslate">
sphere1.attachToBone(skeleton.bones[40], dude);
</pre>
<p><b>attachToBone</b> is a function wherein, you can give any mesh to the bone.</p>
<p><b>Skeleton.bones[30]</b> and <b>skeleton.bones[40]</b> refers to the hands of the skeleton.</p>
<h1>BabylonJS - Physics Engine</h1>
<p>Babylon.js has plugin system for Physics engine which helps to add interactions to the scene.It shows the collision and bouncing between 2 objects and makes it more like real life interaction.The demo will show the balls colliding with each other and moving around with the collision and later resting.We notice the same behavior with games like billiards,where the player hits the ball with the stick and the balls collide with the other balls and so on.Here, the Physics Engine tries to give a realistic view of balls colliding and bouncing when they hit the ground surface. The engine has classes and APIthat help in applying apply impulse, force, changing velocity, callback functions to be called whenever required and also when we need to perform certain actions if the meshes collide against other meshes.</p>
<p>There are 3 Physics plugins that can be used &minus;</p>
<ul class="list">
<li>Cannon.js</li>
<li>Oimo.js</li>
<li>Energy.js</li>
</ul>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Ball/Ground Demo&lt;/title&gt;
      &lt;script type = "text/javascript" src="https://cdn.babylonjs.com/Oimo.js"&gt;&lt;/script&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;	
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var v3 = BABYLON.Vector3;
         
         var createScene = function () {	
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", 0.86, 1.37, 250, BABYLON.Vector3.Zero(), scene);
            
            camera.attachControl(canvas);
            camera.maxZ = 5000;
            camera.lowerRadiusLimit = 120;
            camera.upperRadiusLimit = 430;
            camera.lowerBetaLimit =0.75;
            camera.upperBetaLimit =1.58 ;

            new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);

            var randomNumber = function (min, max) {
               if (min == max) {
                  return (min);
               }
               var random = Math.random();
               return ((random * (max - min)) + min);
            };

            var mat = new BABYLON.StandardMaterial("ground", scene);
            var t = new BABYLON.Texture("images/gr1.jpg", scene);
            t.uScale = t.vScale = 10;
            mat.diffuseTexture = t;
            mat.specularColor = BABYLON.Color3.Black();
            
            var g = BABYLON.Mesh.CreateBox("ground", 200, scene);
            
            g.position.y = -20;
            g.position.x = 0
            g.scaling.y = 0.01;
            g.material = mat;	
            
            scene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
            
            g.physicsImpostor = new BABYLON.PhysicsImpostor(g, BABYLON.PhysicsImpostor.BoxImpostor, { 
               mass: 0, 
               restitution: 0.9 
            }, scene);
            
            var getPosition = function(y) {
               return new v3(randomNumber(-100, 100), y, randomNumber(-100, 100));
            };
            
            var allspheres = [];
            var y = 50;
            var max = 50;
            
            for (var index = 0; index &lt; max; index++) {
               var redSphere = BABYLON.Mesh.CreateSphere("s" + index, 32, 8, scene);
               redSphere.position = getPosition(y);
               redSphere.physicsImpostor = new BABYLON.PhysicsImpostor(redSphere, BABYLON.PhysicsImpostor.SphereImpostor,{
                  mass: 1, restitution:0.9
               }, scene);
               
               redSphere.physicsImpostor.applyImpulse(new BABYLON.Vector3(1, 2, -1), new BABYLON.Vector3(1, 2, 0));
               
               var redMat = new BABYLON.StandardMaterial("ground", scene);
               redMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
               redMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
               redMat.emissiveColor = BABYLON.Color3.Red();
               redSphere.material = redMat;
               
               // push all spheres in the allspheres variable
               allspheres.push(redSphere);			
               y += 10; // increment height
            }
            scene.registerBeforeRender(function() {
               allspheres.forEach(function(obj) { 
                  // if the sphers falls down its updated again over here
                  // If object falls
                  if (obj.position.y &lt; -100) {
                     obj.position = getPosition(200);				
                  }
               });
            })
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/physics_engine.jpg" alt="Physics engine" />
<p>In this demo, we have used image <b>images/gr1.jpg</b>. The images are stored in images/ folder locally and are also pasted below for reference. You can download any image of your choice and use in the demo link.</p> 
<h3>images/gr1.jpg</h3>
<img src="/babylonjs/images/gr1.jpg" alt="GR1" />
<h2>Explanation</h2>
<pre class="result notranslate">
scene.enablePhysics(new BABYLON.Vector3(0,-10,0), new BABYLON.OimoJSPlugin());
</pre>
<p>The above line enables the Physics plugin. You can use the plugin of your choice. We have used OimoJsplugin().</p>
<pre class="result notranslate">
g.physicsImpostor = newBABYLON.PhysicsImpostor(g, BABYLON.PhysicsImpostor.BoxImpostor, { 
   mass: 0, 
   restitution: 0.9 
}, scene);
</pre>
<p>For interaction, Physics engine uses impostor. When applied to impostor, the shape of the object cannot be changed. If changed, a new impostor will have to be created.</p>
<p>For the sphere, we will set the imposter and also added impulse to it for a bounce effect as shown &minus;</p>
<pre class="result notranslate">
redSphere.physicsImpostor = new BABYLON.PhysicsImpostor(
   redSphere, BABYLON.PhysicsImpostor.SphereImpostor, { 
      mass: 1, 
      restitution:0.9
   }, scene
);

redSphere.physicsImpostor.applyImpulse(
   new BABYLON.Vector3(1, 2, -1), 
   new BABYLON.Vector3(1, 2, 0)
);
</pre>
<h2>Parameters for physicsImposter</h2>
<p>Consider the following parameters for Physics effects &minus;</p>
<h2>Object</h2>
<p>Here the object is on which you want to apply the interaction. For example, sphere, box, etc.</p>
<h2>Type</h2>
<p>Type can be one of the following &minus;</p>
<ul class="list">
<li>BABYLON.PhysicsImpostor.SphereImpostor;</li>
<li>BABYLON.PhysicsImpostor.BoxImpostor;</li>
<li>BABYLON.PhysicsImpostor.PlaneImpostor;</li>
<li>BABYLON.PhysicsImpostor.MeshImpostor;</li>
<li>BABYLON.PhysicsImpostor.CylinderImpostor;</li>
<li>BABYLON.PhysicsImpostor.ParticleImpostor;</li>
<li>BABYLON.PhysicsImpostor.HeightmapImpostor;</li>
</ul>
<h2>Mass</h2>
<p>The only mandatory parameter is mass, which is the object's mass in kg. A 0 as a value will create a static impostor - good for floors.</p>
<h2>Restitution</h2>
<p>This is the amount of force the body will "give back" when colliding. A low value will create no bounce and a value of 1 will be a very bouncy interaction.</p>
<pre class="result notranslate">
scene.registerBeforeRender(function() {
   allspheres.forEach(function(obj) { 
      // if the sphers falls down its updated again over here
      // If object falls
      if (obj.position.y &lt; -100) {
         obj.position = getPosition(200);
      }					
   });
})
</pre>
<p>The above code brings back the fallen spheres on the ground. It keeps updating the ground for any fallen sphere. Try the above demo in the browser to see the Physics effect.</p>
<h1>BabylonJS - Playing Sounds and Music</h1>
<p>Without sound and music, a game is incomplete. BabylonJS sound engine comes with an API that helps to add sound effects to the game. When there is a fight seen in the game, you need to get the gunshot firing,  the same can be achieved over here with babylonjs sound engine. You can get the sound effect based on the keyboard/mouse controls effect to the games. The sound engine offers ambient sound, specialized sound and directional sound. The engine supports .mp3 and .wav sound formats.</p>
<h2>Syntax</h2>
<pre class="result notranslate">
var music = new BABYLON.Sound(
   "Music", "sound.wav", scene, null, { 
      loop: true, 
      autoplay: true 
   }
);
</pre>
<h2>Parameters</h2>
<p>Consider the following parameters related to the sound engine &minus;</p>
<ul class="list">
<li><p><b>Name</b> &minus; Name of the sound.</p></li>
<li><p><b>URL</b> &minus; url of the sound to be played.</p></li>
<li><p><b>Scene</b> &minus; Scene to which the sound has to be played.</p></li>
<li><p><b>Callbackfunction</b> &minus; The callbackfunction which is called when the sound is ready to be played.At present, it is null. We will go through a few examples and learn how to use it.</p></li>
<li><p><b>Json object</b> &minus; This object has basic details of what needs to be done.</p></li>
<li><p><b>sound.autoplay</b> &minus; With this, the sound plays automatically once the file is downloaded.</p></li>
<li><p><b>loop:true</b> &minus; This means the sound will continuously play in a loop.</p></li>
</ul>
<p>Create sound folder in your project directory and download any sample audio file to test the output.</p>
<p>Let us now add sound to the scene that we have already created.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Scene- Playing sounds and music&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            var music = new BABYLON.Sound("sound", "sounds/scooby.wav", scene, null, { 
               loop: true, 
               autoplay: true 
            });	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/basic_scene_without_sound.jpg" alt="Basic Scene Without Sound" />
<p>Let us now check how the <b>callback</b> function works. If you do not want the sound to autoplay or you want to play the sound only when you want, you can do so with the callback function.</p>
<p>For example,</p>
<pre class="result notranslate">
Var music = new BABYLON.Sound ("Music", "music.wav", scene, function callback() {music.play();});
</pre>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Scene- Playing sounds and music&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true)
            
            var music = new BABYLON.Sound(
               "sound", "sounds/scooby.wav", scene, function callback() { setTimeout(function() {music.play();}, 5000)});	
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>In the callback,we will use setTimeout. This means, we want the sound to be played only after a specific time. We have added 5s as a timer to it, so the sound will play when the files Scooby.wav is downloaded and 5s complete.</p>
<h2>Play sounds with clicks and keys on the keyboard</h2>
<p>Upon clicking anywhere on the scene, you will hear explosive sound effect and if you press any of the arrow keys -left, right, up or down, it will play the explosive sound effect.</p>
<p>For click, we are attaching the event <b>onmousedown</b> to the window and for keys, we will use the keydown event. Based on keycode, the sound is played.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Scene- Playing sounds and music&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true)
            
            var sound = new BABYLON.Sound("gunshot", "sounds/explosion.wav", scene);

            window.addEventListener("mousedown", function (evt) {	
               if (evt.button === 0) { // onclick
                  sound.play();
               }
            });

            window.addEventListener("keydown", function (evt) { // arrow key left right up down
               if (evt.keyCode === 37 || evt.keyCode === 38 || evt.keyCode === 39 || evt.keyCode === 40) {
                  sound.play();
               }
            });		
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code will generate the following output &minus;</p>
<img src="/babylonjs/images/basic_scene_without_sound.jpg" alt="Basic Scene Without Sound" />
<p>You can control the volume of the sound in the json object, which we encountered in the beginning.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
Var music = new BABYLON.Sound("sound", "sounds/scooby.wav", scene, null, { 
   loop: true, 
   autoplay: true, 
   volume:0.5 
});
</pre>
<p>To know when a sound file has finished, there is an event which can be used as follows &minus;</p>
<pre class="prettyprint notranslate">
music.onended = function () {	
   console.log("sound ended");
   
   //you can do the required stuff here like play it again or play some other sound etc.
};
</pre>
<p>The SetVolume property is also available in case you want to control the sound besides the constructor.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
music.setVolume(volume);
</pre>
<p>If you are playing more than one sound in your scene, you can set a global sound for all the sounds created.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
BABYLON.Engine.audioEngine.setGlobalVolume(0.5);
</pre>
<h2>Creating a Spatial 3D Sound</h2>
<p>If you want to convert the sound to spatial sound (sound similar to space sound), you need to add options to your sound constructor.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
var music = new BABYLON.Sound("music", "sounds/explosion.wav", scene, null, { 
   loop: false, 
   autoplay: true, 
   spatialSound: true 
});
</pre>
<p>Following are the different options for spatial sound &minus;</p>
<ul class="list">
<li><p><b>DistanceModel</b> &minus; It is using a “linear” equation by default. Other options are “inverse” or “exponential”.</p></li>
<li><p><b>MaxDistance</b> &minus; It is set to 100. This means that once the listener is farther than 100 units from the sound, the volume will be 0. You can’t hear the sound anymore</p></li>
<li><p><b>PanningModel</b> &minus; It is set to “HRTF”. The specification says it isa higher quality spatialization algorithm using a convolution with measured impulse responses from human subjects. It refers to the stereo output. </p></li>
<li><p><b>MaxDistance</b> &minus; It is used only when distanceModel is linear.It is not used with inverse or exponential.</p></li>
</ul>
<h2>Demo with spatial sound</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Scene- Playing sounds and music&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);
            
            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);	
            
            var music = new BABYLON.Sound(
               "music", "sounds/explosion.wav", scene, null, {
                  loop: false, autoplay: true, spatialSound: true, distanceModel: "exponential"
               }
            );
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Attaching sound to a mesh</h2>
<p>Using BABYLON.Sound, you can attach sound to your mesh. If the mesh is moving, the sound will move along with it. <b>AttachtoMesh (mesh)</b> is the method to be used.</p>
<h2>Demo</h2>
<pre class="prettyprint notranslate">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;meta charset = "utf-8"&gt;
      &lt;title&gt;BabylonJs - Basic Scene- Playing sounds and music&lt;/title&gt;
      &lt;script src = "babylon.js"&gt;&lt;/script&gt;
      &lt;style&gt;
         canvas {width: 100%; height: 100%;}
      &lt;/style&gt;
   &lt;/head&gt;

   &lt;body&gt;
      &lt;canvas id = "renderCanvas"&gt;&lt;/canvas&gt;
      &lt;script type = "text/javascript"&gt;
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0, 1, 0);

            var camera = new BABYLON.ArcRotateCamera("Camera", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            var materialforbox = new BABYLON.StandardMaterial("texture1", scene);
            var box = BABYLON.Mesh.CreateBox("box", '2', scene);	
            box.material  = materialforbox;
            materialforbox.ambientColor = new BABYLON.Color3(1, 0, 0.2);

            var music = new BABYLON.Sound("music", "sounds/explosion.wav", scene, null, { 
               loop: false, 
               autoplay: true, 
               spatialSound: true, 
               distanceModel: "exponential"
            });	
            music.attachToMesh(box);
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>Output</h2>
<p>The above line of code generates the following output &minus;</p>
<img src="/babylonjs/images/spatial_3d_sound.jpg" alt="Spatial 3D Sound" />
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/babylonjs/babylonjs_playing_sounds_and_music.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/babylonjs/babylonjs_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
