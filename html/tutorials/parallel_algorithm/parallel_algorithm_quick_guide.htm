<!DOCTYPE html>
<html lang="en-US">
<head>
<title>Parallel Algorithm - Quick Guide</title>
<meta charset="utf-8">
<meta name="description" content="Parallel Algorithm - Quick Guide - An algorithm is a sequence of steps that take inputs from the user and after some computation, produces an output. A parallel algorithm is an algorithm that can"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/parallel_algorithm/parallel_algorithm_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#75bab3;
}
a.demo {
    background:#75bab3;
}
li.heading {
    background:#75bab3;
}
.course-box{background:#75bab3}
.home-intro-sub p{color:#75bab3}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/parallel_algorithm/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<div class="mini-logo">
<img src="/parallel_algorithm/images/parallel-algorithm-mini-logo.jpg" alt="Parallel Algorithm Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">Parallel Algorithm Tutorial</li>
<li><a href="/parallel_algorithm/index.htm">Parallel Algorithm Home</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_introduction.htm">Parallel Algorithm Introduction</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_analysis.htm">Parallel Algorithm Analysis</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_models.htm">Parallel Algorithm Models</a></li>
<li><a href="/parallel_algorithm/parallel_random_access_machines.htm">Parallel Random Access Machines</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_structure.htm">Parallel Algorithm Structure</a></li>
<li><a href="/parallel_algorithm/design_techniques.htm">Design Techniques</a></li>
<li><a href="/parallel_algorithm/matrix_multiplication.htm">Matrix Multiplication</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_sorting.htm">Parallel Algorithm - Sorting</a></li>
<li><a href="/parallel_algorithm/parallel_search_algorithm.htm">Parallel Search Algorithm</a></li>
<li><a href="/parallel_algorithm/graph_algorithm.htm">Graph Algorithm</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Parallel Algorithm Useful Resources</li>
<li><a href="/parallel_algorithm/parallel_algorithm_quick_guide.htm">Parallel Algorithm - Quick Guide</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_useful_resources.htm">Parallel Algorithm - Useful Resources</a></li>
<li><a href="/parallel_algorithm/parallel_algorithm_discussion.htm">Parallel Algorithm - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>Parallel Algorithm - Quick Guide</h1>
<hr />
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/parallel_algorithm/graph_algorithm.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/parallel_algorithm/parallel_algorithm_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>Parallel Algorithm - Introduction</h1>
<p>An <b>algorithm</b> is a sequence of steps that take inputs from the user and after some computation, produces an output. A <b>parallel algorithm</b> is an algorithm that can execute several instructions simultaneously on different processing devices and then combine all the individual outputs to produce the final result.</p>
<h2>Concurrent Processing</h2>
<p>The easy availability of computers along with the growth of Internet has changed the way we store and process data. We are living in a day and age where data is available in abundance. Every day we deal with huge volumes of data that require complex computing and that too, in quick time. Sometimes, we need to fetch data from similar or interrelated events that occur simultaneously. This is where we require <b>concurrent processing</b> that can divide a complex task and process it multiple systems to produce the output in quick time.</p>
<p>Concurrent processing is essential where the task involves processing a huge bulk of complex data. Examples include &minus; accessing large databases, aircraft testing, astronomical calculations, atomic and nuclear physics, biomedical analysis, economic planning, image processing, robotics, weather forecasting, web-based services, etc.</p>
<h2>What is Parallelism?</h2>
<p><b>Parallelism</b> is the process of processing several set of instructions simultaneously. It reduces the total computational time. Parallelism can be implemented by using <b>parallel computers,</b> i.e. a computer with many processors. Parallel computers require parallel algorithm, programming languages, compilers and operating system that support multitasking.</p>
<p>In this tutorial, we will discuss only about <b>parallel algorithms</b>. Before moving further, let us first discuss about algorithms and their types.</p>
<h2>What is an Algorithm?</h2>
<p>An <b>algorithm</b> is a sequence of instructions followed to solve a problem. While designing an algorithm, we should consider the architecture of computer on which the algorithm will be executed. As per the architecture, there are two types of computers &minus;</p>
<ul class="list">
<li>Sequential Computer</li>
<li>Parallel Computer</li>
</ul>
<p>Depending on the architecture of computers, we have two types of algorithms &minus;</p>
<ul class="list">
<li><p><b>Sequential Algorithm</b> &minus; An algorithm in which some consecutive steps of instructions are executed in a chronological order to solve a problem.</p></li>
<li><p><b>Parallel Algorithm</b> &minus; The problem is divided into sub-problems and are executed in parallel to get individual outputs. Later on, these individual outputs are combined together to get the final desired output.</p></li>
</ul>
<p>It is not easy to divide a large problem into <b>sub-problems</b>. Sub-problems may have data dependency among them. Therefore, the processors have to communicate with each other to solve the problem.</p>
<p>It has been found that the time needed by the processors in communicating with each other is more than the actual processing time. So, while designing a parallel algorithm, proper CPU utilization should be considered to get an efficient algorithm.</p>
<p>To design an algorithm properly, we must have a clear idea of the basic <b>model of computation</b> in a parallel computer.</p>
<h2>Model of Computation</h2>
<p>Both sequential and parallel computers operate on a set (stream) of instructions called algorithms. These set of instructions (algorithm) instruct the computer about what it has to do in each step.</p>
<p>Depending on the instruction stream and data stream, computers can be classified into four categories &minus;</p>
<ul class="list">
<li>Single Instruction stream, Single Data stream (SISD) computers</li>
<li>Single Instruction stream, Multiple Data stream (SIMD) computers</li>
<li>Multiple Instruction stream, Single Data stream (MISD) computers</li>
<li>Multiple Instruction stream, Multiple Data stream (MIMD) computers</li>
</ul>
<h2>SISD Computers</h2>
<p>SISD computers contain <b>one control unit, one processing unit,</b> and <b>one memory unit</b>.</p>
<img src="/parallel_algorithm/images/sisd_computers.jpg" alt="SSID Computers" />
<p>In this type of computers, the processor receives a single stream of instructions from the control unit and operates on a single stream of data from the memory unit. During computation, at each step, the processor receives one instruction from the control unit and operates on a single data received from the memory unit.</p>
<h2>SIMD Computers</h2>
<p>SIMD computers contain <b>one control unit, multiple processing units,</b> and <b>shared memory or interconnection network</b>.</p>
<img src="/parallel_algorithm/images/simd_computers.jpg" alt="SIMD Computers" />
<p>Here, one single control unit sends instructions to all processing units. During computation, at each step, all the processors receive a single set of instructions from the control unit and operate on different set of data from the memory unit.</p>
<p>Each of the processing units has its own local memory unit to store both data and instructions. In SIMD computers, processors need to communicate among themselves. This is done by <b>shared memory</b> or by <b>interconnection network</b>.</p>
<p>While some of the processors execute a set of instructions, the remaining processors wait for their next set of instructions. Instructions from the control unit decides which processor will be <b>active</b> (execute instructions) or <b>inactive</b> (wait for next instruction).</p>
<h2>MISD Computers</h2>
<p>As the name suggests, MISD computers contain <b>multiple control units, multiple processing units,</b> and <b>one common memory unit</b>.</p>
<img src="/parallel_algorithm/images/misd_computers.jpg" alt="MISD Computers" />
<p>Here, each processor has its own control unit and they share a common memory unit. All the processors get instructions individually from their own control unit and they operate on a single stream of data as per the instructions they have received from their respective control units. This processor operates simultaneously.</p>
<h2>MIMD Computers</h2>
<p>MIMD computers have <b>multiple control units, multiple processing units,</b> and a <b>shared memory</b> or <b>interconnection network</b>.</p>
<img src="/parallel_algorithm/images/mimd_computers.jpg" alt="MIMD Computers" />
<p>Here, each processor has its own control unit, local memory unit, and arithmetic and logic unit. They receive different sets of instructions from their respective control units and operate on different sets of data.</p>
<h3>Note</h3>
<ul class="list">
<li><p>An MIMD computer that shares a common memory is known as <b>multiprocessors,</b> while those that uses an interconnection network is known as <b>multicomputers</b>.</p></li>
<li><p>Based on the physical distance of the processors, multicomputers are of two types &minus;</p>
<ul class="list">
<li><p><b>Multicomputer</b> &minus; When all the processors are very close to one another (e.g., in the same room).</p></li>
<li><p><b>Distributed system</b> &minus; When all the processors are far away from one another (e.g.- in the different cities)</p></li>
</ul>
</li>
</ul>
<h1>Parallel Algorithm - Analysis</h1>
<p>Analysis of an algorithm helps us determine whether the algorithm is useful or not. Generally, an algorithm is analyzed based on its execution time <b>(Time Complexity)</b> and the amount of space <b>(Space Complexity)</b> it requires.</p>
<p>Since we have sophisticated memory devices available at reasonable cost, storage space is no longer an issue. Hence, space complexity is not given so much of importance.</p>
<p>Parallel algorithms are designed to improve the computation speed of a computer. For analyzing a Parallel Algorithm, we normally consider the following parameters &minus;</p>
<ul class="list">
<li>Time complexity (Execution Time),</li>
<li>Total number of processors used, and</li>
<li>Total cost.</li>
</ul>
<h2>Time Complexity</h2>
<p>The main reason behind developing parallel algorithms was to reduce the computation time of an algorithm. Thus, evaluating the execution time of an algorithm is extremely important in analyzing its efficiency.</p>
<p>Execution time is measured on the basis of the time taken by the algorithm to solve a problem. The total execution time is calculated from the moment when the algorithm starts executing to the moment it stops. If all the processors do not start or end execution at the same time, then the total execution time of the algorithm is the moment when the first processor started its execution to the moment when the last processor stops its execution.</p>
<p>Time complexity of an algorithm can be classified into three categories&minus;</p>
<ul class="list">
<li><p><b>Worst-case complexity</b> &minus; When the amount of time required by an algorithm for a given input is <b>maximum</b>.</p></li>
<li><p><b>Average-case complexity</b> &minus; When the amount of time required by an algorithm for a given input is <b>average</b>.</p></li>
<li><p><b>Best-case complexity</b> &minus; When the amount of time required by an algorithm for a given input is <b>minimum</b>.</p></li>
</ul>
<h2>Asymptotic Analysis</h2>
<p>The complexity or efficiency of an algorithm is the number of steps executed by the algorithm to get the desired output. Asymptotic analysis is done to calculate the complexity of an algorithm in its theoretical analysis. In asymptotic analysis, a large length of input is used to calculate the complexity function of the algorithm.</p>
<p><b>Note</b> &minus; <b>Asymptotic</b> is a condition where a line tends to meet a curve, but they do not intersect. Here the line and the curve is asymptotic to each other.</p>
<p>Asymptotic notation is the easiest way to describe the fastest and slowest possible execution time for an algorithm using high bounds and low bounds on speed. For this, we use the following notations &minus;</p>
<ul class="list">
<li>Big O notation</li>
<li>Omega notation</li>
<li>Theta notation</li>
</ul>
<h3>Big O notation</h3>
<p>In mathematics, Big O notation is used to represent the asymptotic characteristics of functions. It represents the behavior of a function for large inputs in a simple and accurate method. It is a method of representing the upper bound of an algorithm’s execution time. It represents the longest amount of time that the algorithm could take to complete its execution. The function &minus;</p>
<p style="text-align:center;">f(n) = O(g(n))</p>
<p>iff there exists positive constants <b>c</b> and <b>n<sub>0</sub></b> such that <b>f(n) &le; c * g(n)</b> for all <b>n</b> where <b>n &ge; n<sub>0</sub></b>.</p>
<h3>Omega notation</h3>
<p>Omega notation is a method of representing the lower bound of an algorithm’s execution time. The function &minus;</p>
<p style="text-align:center;">f(n) = &Omega; (g(n))</p>
<p>iff there exists positive constants <b>c</b> and <b>n<sub>0</sub></b> such that <b>f(n) &ge; c * g(n)</b> for all <b>n</b> where <b>n &ge; n<sub>0</sub></b>.</p>
<h3>Theta Notation</h3>
<p>Theta notation is a method of representing both the lower bound and the upper bound of an algorithm’s execution time. The function &minus;</p>
<p style="text-align:center;">f(n) = &theta;(g(n))</p>
<p>iff there exists positive constants <b>c<sub>1</sub>, c<sub>2</sub>,</b> and <b>n<sub>0</sub></b> such that c1 * g(n) &le; f(n) &le; c2 * g(n) for all <b>n</b> where <b>n &ge; n<sub>0</sub></b>.</p>
<h2>Speedup of an Algorithm</h2>
<p>The performance of a parallel algorithm is determined by calculating its <b>speedup</b>. Speedup is defined as the ratio of the worst-case execution time of the fastest known sequential algorithm for a particular problem to the worst-case execution time of the parallel algorithm.</p>
<div style="font-size:0.9em;">
speedup = 
<div class="fraction">
<span class="fup">Worst case execution time of the fastest known sequential for a particular problem</span>
<span class="bar">/</span>
<span class="fdn">Worst case execution time of the parallel algorithm</span>
</div>
</div>
<h2>Number of Processors Used</h2>
<p>The number of processors used is an important factor in analyzing the efficiency of a parallel algorithm. The cost to buy, maintain, and run the computers are calculated. Larger the number of processors used by an algorithm to solve a problem, more costly becomes the obtained result.</p>
<h2>Total Cost</h2>
<p>Total cost of a parallel algorithm is the product of time complexity and the number of processors used in that particular algorithm.</p>
<p style="text-align:center;">Total Cost = Time complexity &times; Number of processors used</p>
<p>Therefore, the <b>efficiency</b> of a parallel algorithm is &minus;</p>
<div style="text-align:center;">
Efficiency = 
<div class="fraction">
<span class="fup">Worst case execution time of sequential algorithm</span>
<span class="bar">/</span>
<span class="fdn">Worst case execution time of the parallel algorithm</span>
</div>
</div>
<h1>Parallel Algorithm - Models</h1>
<p>The model of a parallel algorithm is developed by considering a strategy for dividing the data and processing method and applying a suitable strategy to reduce interactions. In this chapter, we will discuss the following Parallel Algorithm Models &minus;</p>
<ul class="list">
<li>Data parallel model</li>
<li>Task graph model</li>
<li>Work pool model</li>
<li>Master slave model</li>
<li>Producer consumer or pipeline model</li>
<li>Hybrid model</li>
</ul>
<h2>Data Parallel</h2>
<p>In data parallel model, tasks are assigned to processes and each task performs similar types of operations on different data. <b>Data parallelism</b> is a consequence of single operations that is being applied on multiple data items.</p>
<p>Data-parallel model can be applied on shared-address spaces and message-passing paradigms. In data-parallel model, interaction overheads can be reduced by selecting a locality preserving decomposition, by using optimized collective interaction routines, or by overlapping computation and interaction.</p>
<p>The primary characteristic of data-parallel model problems is that the intensity of data parallelism increases with the size of the problem, which in turn makes it possible to use more processes to solve larger problems.</p>
<p><b>Example</b> &minus; Dense matrix multiplication.</p>
<img src="/parallel_algorithm/images/data_parallel_model.jpg" alt="Data Parallel Model" />
<h2>Task Graph Model</h2>
<p>In the task graph model, parallelism is expressed by a <b>task graph</b>. A task graph can be either trivial or nontrivial. In this model, the correlation among the tasks are utilized to promote locality or to minimize interaction costs. This model is enforced to solve problems in which the quantity of data associated with the tasks is huge compared to the number of computation associated with them. The tasks are assigned to help improve the cost of data movement among the tasks.</p>
<p><b>Examples</b> &minus; Parallel quick sort, sparse matrix factorization, and parallel algorithms derived via divide-and-conquer approach.</p>
<img src="/parallel_algorithm/images/task_graph_model.jpg" alt="Task Graph Model" />
<p>Here, problems are divided into atomic tasks and implemented as a graph. Each task is an independent unit of job that has dependencies on one or more antecedent task. After the completion of a task, the output of an antecedent task is passed to the dependent task. A task with antecedent task starts execution only when its entire antecedent task is completed. The final output of the graph is received when the last dependent task is completed (Task 6 in the above figure).</p>
<h2>Work Pool Model</h2>
<p>In work pool model, tasks are dynamically assigned to the processes for balancing the load. Therefore, any process may potentially execute any task. This model is used when the quantity of data associated with tasks is comparatively smaller than the computation associated with the tasks.</p>
<p>There is no desired pre-assigning of tasks onto the processes. Assigning of tasks is centralized or decentralized. Pointers to the tasks are saved in a physically shared list, in a priority queue, or in a hash table or tree, or they could be saved in a physically distributed data structure.</p>
<p>The task may be available in the beginning, or may be generated dynamically. If the task is generated dynamically and a decentralized assigning of task is done, then a termination detection algorithm is required so that all the processes can actually detect the completion of the entire program and stop looking for more tasks.</p>
<p><b>Example</b> &minus; Parallel tree search</p>
<img src="/parallel_algorithm/images/work_pool_model.jpg" alt="Work Pool Model" />
<h2>Master-Slave Model</h2>
<p>In the master-slave model, one or more master processes generate task and allocate it to slave processes. The tasks may be allocated beforehand if &minus;</p>
<ul class="list">
<li>the master can estimate the volume of the tasks, or</li>
<li>a random assigning can do a satisfactory job of balancing load, or</li>
<li>slaves are assigned smaller pieces of task at different times.</li>
</ul>
<p>This model is generally equally suitable to <b>shared-address-space</b> or <b>message-passing paradigms,</b> since the interaction is naturally two ways.</p>
<p>In some cases, a task may need to be completed in phases, and the task in each phase must be completed before the task in the next phases can be generated. The master-slave model can be generalized to <b>hierarchical</b> or <b>multi-level master-slave model</b> in which the top level master feeds the large portion of tasks to the second-level master, who further subdivides the tasks among its own slaves and may perform a part of the task itself.</p>
<img src="/parallel_algorithm/images/master_slave_model.jpg" alt="Master-Slave Model" />
<h3>Precautions in using the master-slave model</h3>
<p>Care should be taken to assure that the master does not become a congestion point. It may happen if the tasks are too small or the workers are comparatively fast.</p>
<p>The tasks should be selected in a way that the cost of performing a task dominates the cost of communication and the cost of synchronization.</p>
<p>Asynchronous interaction may help overlap interaction and the computation associated with work generation by the master.</p>
<h2>Pipeline Model</h2>
<p>It is also known as the <b>producer-consumer model</b>. Here a set of data is passed on through a series of processes, each of which performs some task on it. Here, the arrival of new data generates the execution of a new task by a process in the queue. The processes could form a queue in the shape of linear or multidimensional arrays, trees, or general graphs with or without cycles.</p>
<p>This model is a chain of producers and consumers. Each process in the queue can be considered as a consumer of a sequence of data items for the process preceding it in the queue and as a producer of data for the process following it in the queue. The queue does not need to be a linear chain; it can be a directed graph. The most common interaction minimization technique applicable to this model is overlapping interaction with computation.</p>
<p><b>Example</b> &minus; Parallel LU factorization algorithm.</p>
<img src="/parallel_algorithm/images/pipeline_model.jpg" alt="Pipeline Model" />
<h2>Hybrid Models</h2>
<p>A hybrid algorithm model is required when more than one model may be needed to solve a problem.</p>
<p>A hybrid model may be composed of either multiple models applied hierarchically or multiple models applied sequentially to different phases of a parallel algorithm.</p>
<p><b>Example</b> &minus; Parallel quick sort</p>
<h1>Parallel Random Access Machines</h1>
<p><b>Parallel Random Access Machines (PRAM)</b> is a model, which is considered for most of the parallel algorithms. Here, multiple processors are attached to a single block of memory. A PRAM model contains &minus;</p>
<ul class="list">
<li><p>A set of similar type of processors.</p></li>
<li><p>All the processors share a common memory unit. Processors can communicate among themselves through the shared memory only.</p></li>
<li><p>A memory access unit (MAU) connects the processors with the single shared memory.</p></li>
</ul>
<img src="/parallel_algorithm/images/pram_architecture.jpg" alt="PRAM Architecture" />
<p>Here, <b>n</b> number of processors can perform independent operations on <b>n</b> number of data in a particular unit of time. This may result in simultaneous access of same memory location by different processors.</p>
<p>To solve this problem, the following constraints have been enforced on PRAM model &minus;</p>
<ul class="list">
<li><p><b>Exclusive Read Exclusive Write (EREW)</b> &minus; Here no two processors are allowed to read from or write to the same memory location at the same time.</p></li>
<li><p><b>Exclusive Read Concurrent Write (ERCW)</b> &minus; Here no two processors are allowed to read from the same memory location at the same time, but are allowed to write to the same memory location at the same time.</p></li>
<li><p><b>Concurrent Read Exclusive Write (CREW)</b> &minus; Here all the processors are allowed to read from the same memory location at the same time, but are not allowed to write to the same memory location at the same time.</p></li>
<li><p><b>Concurrent Read Concurrent Write (CRCW)</b> &minus; All the processors are allowed to read from or write to the same memory location at the same time.</p></li>
</ul>
<p>There are many methods to implement the PRAM model, but the most prominent ones are &minus;</p>
<ul class="list">
<li>Shared memory model</li>
<li>Message passing model</li>
<li>Data parallel model</li>
</ul>
<h2>Shared Memory Model</h2>
<p>Shared memory emphasizes on <b>control parallelism</b> than on <b>data parallelism</b>. In the shared memory model, multiple processes execute on different processors independently, but they share a common memory space. Due to any processor activity, if there is any change in any memory location, it is visible to the rest of the processors.</p>
<p>As multiple processors access the same memory location, it may happen that at any particular point of time, more than one processor is accessing the same memory location. Suppose one is reading that location and the other is writing on that location. It may create confusion. To avoid this, some control mechanism, like <b>lock / semaphore,</b> is implemented to ensure mutual exclusion.</p>
<img src="/parallel_algorithm/images/shared_memory_model.jpg" alt="Shared Memory Model" />
<p>Shared memory programming has been implemented in the following &minus;</p>
<ul class="list">
<li><p><b>Thread libraries</b> &minus; The thread library allows multiple threads of control that run concurrently in the same memory location. Thread library provides an interface that supports multithreading through a library of subroutine. It contains subroutines for</p>
<ul class="list">
<li>Creating and destroying threads</li>
<li>Scheduling execution of thread</li>
<li>passing data and message between threads</li>
<li>saving and restoring thread contexts</li>
</ul>
</li>
</ul>
<p>Examples of thread libraries include &minus; SolarisTM threads for Solaris, POSIX threads as implemented in Linux, Win32 threads available in Windows NT and Windows 2000, and JavaTM threads as part of the standard JavaTM Development Kit (JDK).</p>
<ul class="list">
<li><p><b>Distributed Shared Memory (DSM) Systems</b> &minus; DSM systems create an abstraction of shared memory on loosely coupled architecture in order to implement shared memory programming without hardware support. They implement standard libraries and use the advanced user-level memory management features present in modern operating systems. Examples include Tread Marks System, Munin, IVY, Shasta, Brazos, and Cashmere.</p></li>
<li><p><b>Program Annotation Packages</b> &minus; This is implemented on the architectures having uniform memory access characteristics. The most notable example of program annotation packages is OpenMP. OpenMP implements functional parallelism. It mainly focuses on parallelization of loops.</p></li>
</ul>
<p>The concept of shared memory provides a low-level control of shared memory system, but it tends to be tedious and erroneous. It is more applicable for system programming than application programming.</p>
<h3>Merits of Shared Memory Programming</h3>
<ul class="list">
<li><p>Global address space gives a user-friendly programming approach to memory.</p></li>
<li><p>Due to the closeness of memory to CPU, data sharing among processes is fast and uniform.</p></li>
<li><p>There is no need to specify distinctly the communication of data among processes.</p></li>
<li><p>Process-communication overhead is negligible.</p></li>
<li><p>It is very easy to learn.</p></li>
</ul>
<h3>Demerits of Shared Memory Programming</h3>
<ul class="list">
<li>It is not portable.</li>
<li>Managing data locality is very difficult.</li>
</ul>
<h2>Message Passing Model</h2>
<p>Message passing is the most commonly used parallel programming approach in distributed memory systems. Here, the programmer has to determine the parallelism. In this model, all the processors have their own local memory unit and they exchange data through a communication network.</p>
<img src="/parallel_algorithm/images/message_passing_model.jpg" alt="Message Passing Model" />
<p>Processors use message-passing libraries for communication among themselves. Along with the data being sent, the message contains the following components &minus;</p>
<ul class="list">
<li><p>The address of the processor from which the message is being sent;</p></li>
<li><p>Starting address of the memory location of the data in the sending processor;</p></li>
<li><p>Data type of the sending data;</p></li>
<li><p>Data size of the sending data;</p></li>
<li><p>The address of the processor to which the message is being sent;</p></li>
<li><p>Starting address of the memory location for the data in the receiving processor.</p></li>
</ul>
<p>Processors can communicate with each other by any of the following methods &minus;</p>
<ul class="list">
<li>Point-to-Point Communication</li>
<li>Collective Communication</li>
<li>Message Passing Interface</li>
</ul>
<h3>Point-to-Point Communication</h3>
<p>Point-to-point communication is the simplest form of message passing. Here, a message can be sent from the sending processor to a receiving processor by any of the following transfer modes &minus;</p>
<ul class="list">
<li><p><b>Synchronous mode</b> &minus; The next message is sent only after the receiving a confirmation that its previous message has been delivered, to maintain the sequence of the message.</p></li>
<li><p><b>Asynchronous mode</b> &minus; To send the next message, receipt of the confirmation of the delivery of the previous message is not required.</p></li>
</ul>
<h3>Collective Communication</h3>
<p>Collective communication involves more than two processors for message passing. Following modes allow collective communications &minus;</p>
<ul class="list">
<li><p><b>Barrier</b> &minus; Barrier mode is possible if all the processors included in the communications run a particular bock (known as <b>barrier block</b>) for message passing.</p></li>
<li><p><b>Broadcast</b> &minus; Broadcasting is of two types &minus;</p>
<ul class="list">
<li><p><b>One-to-all</b> &minus; Here, one processor with a single operation sends same message to all other processors.</p></li>
<li><p><b>All-to-all</b> &minus; Here, all processors send message to all other processors.</p></li>
</ul>
</li>
</ul>
<p>Messages broadcasted may be of three types &minus;</p>
<ul class="list">
<li><p><b>Personalized</b> &minus; Unique messages are sent to all other destination processors.</p></li>
<li><p><b>Non-personalized</b> &minus; All the destination processors receive the same message.</p></li>
<li><p><b>Reduction</b> &minus; In reduction broadcasting, one processor of the group collects all the messages from all other processors in the group and combine them to a single message which all other processors in the group can access.</p></li>
</ul>
<h3>Merits of Message Passing</h3>
<ul class="list">
<li>Provides low-level control of parallelism;</li>
<li>It is portable;</li>
<li>Less error prone;</li>
<li>Less overhead in parallel synchronization and data distribution.</li>
</ul>
<h3>Demerits of Message Passing</h3>
<ul class="list">
<li><p>As compared to parallel shared-memory code, message-passing code generally needs more software overhead.</p></li>
</ul>
<h3>Message Passing Libraries</h3>
<p>There are many message-passing libraries. Here, we will discuss two of the most-used message-passing libraries &minus;</p>
<ul class="list">
<li>Message Passing Interface (MPI)</li>
<li>Parallel Virtual Machine (PVM)</li>
</ul>
<h4>Message Passing Interface (MPI)</h4>
<p>It is a universal standard to provide communication among all the concurrent processes in a distributed memory system. Most of the commonly used parallel computing platforms provide at least one implementation of message passing interface. It has been implemented as the collection of predefined functions called <b>library</b> and can be called from languages such as C, C++, Fortran, etc. MPIs are both fast and portable as compared to the other message passing libraries.</p>
<p><b>Merits of Message Passing Interface</b></p>
<ul class="list">
<li><p>Runs only on shared memory architectures or distributed memory architectures;</p></li>
<li><p>Each processors has its own local variables;</p></li>
<li><p>As compared to large shared memory computers, distributed memory computers are less expensive.</p></li>
</ul>
<p><b>Demerits of Message Passing Interface</b></p>
<ul class="list">
<li>More programming changes are required for parallel algorithm;</li>
<li>Sometimes difficult to debug; and</li>
<li>Does not perform well in the communication network between the nodes.</li>
</ul>
<h4>Parallel Virtual Machine (PVM)</h4>
<p>PVM is a portable message passing system, designed to connect separate heterogeneous host machines to form a single virtual machine. It is a single manageable parallel computing resource. Large computational problems like superconductivity studies, molecular dynamics simulations, and matrix algorithms can be solved more cost effectively by using the memory and the aggregate power of many computers. It manages all message routing, data conversion, task scheduling in the network of incompatible computer architectures.</p>
<p><b>Features of PVM</b></p>
<ul class="list">
<li>Very easy to install and configure;</li>
<li>Multiple users can use PVM at the same time;</li>
<li>One user can execute multiple applications;</li>
<li>It’s a small package;</li>
<li>Supports C, C++, Fortran;</li>
<li>For a given run of a PVM program, users can select the group of machines;</li>
<li>It is a message-passing model,</li>
<li>Process-based computation;</li>
<li>Supports heterogeneous architecture.</li>
</ul>
<h2>Data Parallel Programming</h2>
<p>The major focus of data parallel programming model is on performing operations on a data set simultaneously. The data set is organized into some structure like an array, hypercube, etc. Processors perform operations collectively on the same data structure. Each task is performed on a different partition of the same data structure.</p>
<p>It is restrictive, as not all the algorithms can be specified in terms of data parallelism. This is the reason why data parallelism is not universal.</p>
<p>Data parallel languages help to specify the data decomposition and mapping to the processors. It also includes data distribution statements that allow the programmer to have control on data – for example, which data will go on which processor – to reduce the amount of communication within the processors.</p>
<h1>Parallel Algorithm - Structure</h1>
<p>To apply any algorithm properly, it is very important that you select a proper data structure. It is because a particular operation performed on a data structure may take more time as compared to the same operation performed on another data structure.</p>
<p><b>Example</b> &minus; To access the i<sup>th</sup> element in a set by using an array, it may take a constant time but by using a linked list, the time required to perform the same operation may become a polynomial.</p>
<p>Therefore, the selection of a data structure must be done considering the architecture and the type of operations to be performed.</p>
<p>The following data structures are commonly used in parallel programming &minus;</p>
<ul class="list">
<li>Linked List</li>
<li>Arrays</li>
<li>Hypercube Network</li>
</ul>
<h2>Linked List</h2>
<p>A linked list is a data structure having zero or more nodes connected by pointers. Nodes may or may not occupy consecutive memory locations. Each node has two or three parts &minus; one <b>data part</b> that stores the data and the other two are <b>link fields</b> that store the address of the previous or next node. The first node’s address is stored in an external pointer called <b>head</b>. The last node, known as <b>tail,</b> generally does not contain any address.</p>
<p>There are three types of linked lists &minus;</p>
<ul class="list">
<li>Singly Linked List</li>
<li>Doubly Linked List</li>
<li>Circular Linked List</li>
</ul>
<h3>Singly Linked List</h3>
<p>A node of a singly linked list contains data and the address of the next node. An external pointer called <b>head</b> stores the address of the first node.</p>
<img src="/parallel_algorithm/images/singly_linked_list.jpg" alt="Singly Linked List" />
<h3>Doubly Linked List</h3>
<p>A node of a doubly linked list contains data and the address of both the previous and the next node. An external pointer called <b>head</b> stores the address of the first node and the external pointer called <b>tail</b> stores the address of the last node.</p>
<img src="/parallel_algorithm/images/doubly_linked_list.jpg" alt="Doubly Linked List" />
<h3>Circular Linked List</h3>
<p>A circular linked list is very similar to the singly linked list except the fact that the last node saved the address of the first node.</p>
<img src="/parallel_algorithm/images/circular_linked_list.jpg" alt="Circular Linked List" />
<h2>Arrays</h2>
<p>An array is a data structure where we can store similar types of data. It can be one-dimensional or multi-dimensional. Arrays can be created statically or dynamically.</p>
<ul class="list">
<li><p>In <b>statically declared arrays,</b> dimension and size of the arrays are known at the time of compilation.</p></li>
<li><p>In <b>dynamically declared arrays,</b> dimension and size of the array are known at runtime.</p></li>
</ul>
<p>For shared memory programming, arrays can be used as a common memory and for data parallel programming, they can be used by partitioning into sub-arrays.</p>
<h2>Hypercube Network</h2>
<p>Hypercube architecture is helpful for those parallel algorithms where each task has to communicate with other tasks. Hypercube topology can easily embed other topologies such as ring and mesh. It is also known as n-cubes, where <b>n</b> is the number of dimensions. A hypercube can be constructed recursively.</p>
<img src="/parallel_algorithm/images/hypercube.jpg" alt="Hypercube" />
<img src="/parallel_algorithm/images/hypercube1.jpg" alt="Hypercube 1" />
<h1>Parallel Algorithm - Design Techniques</h1>
<p>Selecting a proper designing technique for a parallel algorithm is the most difficult and important task. Most of the parallel programming problems may have more than one solution. In this chapter, we will discuss the following designing techniques for parallel algorithms &minus;</p>
<ul class="list">
<li>Divide and conquer</li>
<li>Greedy Method</li>
<li>Dynamic Programming</li>
<li>Backtracking</li>
<li>Branch &amp; Bound</li>
<li>Linear Programming</li>
</ul>
<h2>Divide and Conquer Method</h2>
<p>In the divide and conquer approach, the problem is divided into several small sub-problems. Then the sub-problems are solved recursively and combined to get the solution of the original problem.</p>
<p>The divide and conquer approach involves the following steps at each level &minus;</p>
<ul class="list">
<li><p><b>Divide</b> &minus; The original problem is divided into sub-problems.</p></li>
<li><p><b>Conquer</b> &minus; The sub-problems are solved recursively.</p></li>
<li><p><b>Combine</b> &minus; The solutions of the sub-problems are combined together to get the solution of the original problem.</p></li>
</ul>
<p>The divide and conquer approach is applied in the following algorithms &minus;</p>
<ul class="list">
<li>Binary search</li>
<li>Quick sort</li>
<li>Merge sort</li>
<li>Integer multiplication</li>
<li>Matrix inversion</li>
<li>Matrix multiplication</li>
</ul>
<h2>Greedy Method</h2>
<p>In greedy algorithm of optimizing solution, the best solution is chosen at any moment. A greedy algorithm is very easy to apply to complex problems. It decides which step will provide the most accurate solution in the next step.</p>
<p>This algorithm is a called <b>greedy</b> because when the optimal solution to the smaller instance is provided, the algorithm does not consider the total program as a whole. Once a solution is considered, the greedy algorithm never considers the same solution again.</p>
<p>A greedy algorithm works recursively creating a group of objects from the smallest possible component parts. Recursion is a procedure to solve a problem in which the solution to a specific problem is dependent on the solution of the smaller instance of that problem.</p>
<h2>Dynamic Programming</h2>
<p>Dynamic programming is an optimization technique, which divides the problem into smaller sub-problems and after solving each sub-problem, dynamic programming combines all the solutions to get ultimate solution. Unlike divide and conquer method, dynamic programming reuses the solution to the sub-problems many times.</p>
<p>Recursive algorithm for Fibonacci Series is an example of dynamic programming.</p>
<h2>Backtracking Algorithm</h2>
<p>Backtracking is an optimization technique to solve combinational problems. It is applied to both programmatic and real-life problems. Eight queen problem, Sudoku puzzle and going through a maze are popular examples where backtracking algorithm is used.</p>
<p>In backtracking, we start with a possible solution, which satisfies all the required conditions. Then we move to the next level and if that level does not produce a satisfactory solution, we return one level back and start with a new option.</p>
<h2>Branch and Bound</h2>
<p>A branch and bound algorithm is an optimization technique to get an optimal solution to the problem. It looks for the best solution for a given problem in the entire space of the solution. The bounds in the function to be optimized are merged with the value of the latest best solution. It allows the algorithm to find parts of the solution space completely.</p>
<p>The purpose of a branch and bound search is to maintain the lowest-cost path to a target. Once a solution is found, it can keep improving the solution. Branch and bound search is implemented in depth-bounded search and depth–first search.</p>
<h2>Linear Programming</h2>
<p>Linear programming describes a wide class of optimization job where both the optimization criterion and the constraints are linear functions. It is a technique to get the best outcome like maximum profit, shortest path, or lowest cost.</p>
<p>In this programming, we have a set of variables and we have to assign absolute values to them to satisfy a set of linear equations and to maximize or minimize a given linear objective function.</p>
<h1>Parallel Algorithm - Matrix Multiplication</h1>
<p>A matrix is a set of numerical and non-numerical data arranged in a fixed number of rows and column. Matrix multiplication is an important multiplication design in parallel computation. Here, we will discuss the implementation of matrix multiplication on various communication networks like mesh and hypercube. Mesh and hypercube have higher network connectivity, so they allow faster algorithm than other networks like ring network.</p>
<h2>Mesh Network</h2>
<p>A topology where a set of nodes form a p-dimensional grid is called a mesh topology. Here, all the edges are parallel to the grid axis and all the adjacent nodes can communicate among themselves.</p>
<p style="text-align:center;">Total number of nodes = (number of nodes in row) &times; (number of nodes in column)</p>
<p>A mesh network can be evaluated using the following factors &minus;</p>
<ul class="list">
<li>Diameter</li>
<li>Bisection width</li>
</ul>
<p><b>Diameter</b> &minus; In a mesh network, the longest <b>distance</b> between two nodes is its diameter. A p-dimensional mesh network having <b>kP</b> nodes has a diameter of <b>p(k–1)</b>.</p>
<p><b>Bisection width</b> &minus; Bisection width is the minimum number of edges needed to be removed from a network to divide the mesh network into two halves.</p>
<h3>Matrix Multiplication Using Mesh Network</h3>
<p>We have considered a 2D mesh network SIMD model having wraparound connections. We will design an algorithm to multiply two n &times; n arrays using n<sup>2</sup> processors in a particular amount of time.</p>
<p>Matrices A and B have elements a<sub>ij</sub> and b<sub>ij</sub> respectively. Processing element PE<sub>ij</sub> represents a<sub>ij</sub> and b<sub>ij</sub>. Arrange the matrices A and B in such a way that every processor has a pair of elements to multiply. The elements of matrix A will move in left direction and the elements of matrix B will move in upward direction. These changes in the position of the elements in matrix A and B present each processing element, PE, a new pair of values to multiply.</p>
<h3>Steps in Algorithm</h3>
<ul class="list">
<li>Stagger two matrices.</li>
<li>Calculate all products, a<sub>ik</sub> &times; b<sub>kj</sub></li>
<li>Calculate sums when step 2 is complete.</li>
</ul>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
Procedure MatrixMulti

Begin
   for k = 1 to n-1
	
   for all Pij; where i and j ranges from 1 to n
      ifi is greater than k then
         rotate a in left direction
      end if
		
   if j is greater than k then
      rotate b in the upward direction
   end if
	
   for all Pij ; where i and j lies between 1 and n
      compute the product of a and b and store it in c
   for k= 1 to n-1 step 1
   for all Pi;j where i and j ranges from 1 to n
      rotate a in left direction
      rotate b in the upward direction
      c=c+aXb
End
</pre>
<h2>Hypercube Network</h2>
<p>A hypercube is an n-dimensional construct where edges are perpendicular among themselves and are of same length. An n-dimensional hypercube is also known as an n-cube or an n-dimensional cube.</p>
<h3>Features of Hypercube with 2<sup>k</sup> node</h3>
<ul class="list">
<li>Diameter = k</li>
<li>Bisection width = 2<sup>k–1</sup></li>
<li>Number of edges = k</li>
</ul>
<h3>Matrix Multiplication using Hypercube Network</h3>
<p>General specification of Hypercube networks &minus;</p>
<ul class="list">
<li><p>Let <b>N = 2<sup>m</sup></b> be the total number of processors. Let the processors be P<sub>0,</sub> P<sub>1</sub>…..P<sub>N-1</sub>.</p></li>
<li><p>Let i and i<sup>b</sup> be two integers, 0 &lt; i,i<sup>b</sup> &lt; N-1 and its binary representation differ only in position b, 0 &lt; b &lt; k–1.</p></li>
<li><p>Let us consider two n &times; n matrices, matrix A and matrix B.</p></li>
<li><p><b>Step 1</b> &minus; The elements of matrix A and matrix B are assigned to the n<sup>3</sup> processors such that the processor in position i, j, k will have a<sub>ji</sub> and b<sub>ik</sub>.</p></li>
<li><p><b>Step 2</b> &minus; All the processor in position (i,j,k) computes the product</p>
<p style="text-align:center;">C(i,j,k) = A(i,j,k) &times; B(i,j,k)</p></li>
<li><p><b>Step 3</b> &minus; The sum C(0,j,k) = &Sigma;C(i,j,k) for 0 &le; i &le; n-1, where 0 &le; j, k &lt; n–1.</p></li>
</ul>
<h2>Block Matrix</h2>
<p>Block Matrix or partitioned matrix is a matrix where each element itself represents an individual matrix. These individual sections are known as a <b>block</b> or <b>sub-matrix</b>.</p>
<h3>Example</h3>
<img src="/parallel_algorithm/images/block_matrix.jpg" alt="Block Matrix" />
<img src="/parallel_algorithm/images/block_matrix1.jpg" alt="Block Matrix 1" />
<p>In Figure (a), X is a block matrix where A, B, C, D are matrix themselves. Figure (f) shows the total matrix.</p>
<h2>Block Matrix Multiplication</h2>
<p>When two block matrices are square matrices, then they are multiplied just the way we perform simple matrix multiplication. For example,</p>
<img src="/parallel_algorithm/images/block_matrix_multiplication.jpg" alt="Block Matrix Multiplication" />
<h1>Parallel Algorithm - Sorting</h1>
<p>Sorting is a process of arranging elements in a group in a particular order, i.e., ascending order, descending order, alphabetic order, etc. Here we will discuss the following &minus;</p>
<ul class="list">
<li>Enumeration Sort</li>
<li>Odd-Even Transposition Sort</li>
<li>Parallel Merge Sort</li>
<li>Hyper Quick Sort</li>
</ul>
<p>Sorting a list of elements is a very common operation. A sequential sorting algorithm may not be efficient enough when we have to sort a huge volume of data. Therefore, parallel algorithms are used in sorting.</p>
<h2>Enumeration Sort</h2>
<p>Enumeration sort is a method of arranging all the elements in a list by finding the final position of each element in a sorted list. It is done by comparing each element with all other elements and finding the number of elements having smaller value.</p>
<p>Therefore, for any two elements, a<sub>i</sub> and a<sub>j</sub> any one of the following cases must be true &minus;</p>
<ul class="list">
<li>a<sub>i</sub> &lt; a<sub>j</sub></li>
<li>a<sub>i</sub> &gt; a<sub>j</sub></li>
<li>a<sub>i</sub> = a<sub>j</sub></li>
</ul>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
procedure ENUM_SORTING (n)

begin
   for each process P<sub>1,j</sub> do
      C[j] := 0;
		
   for each process P<sub>i, j</sub> do
	
      if (A[i] &lt; A[j]) or A[i] = A[j] and i &lt; j) then
         C[j] := 1;
      else
         C[j] := 0;
			
   for each process P1, j do
      A[C[j]] := A[j];
		
end ENUM_SORTING
</pre>
<h2>Odd-Even Transposition Sort</h2>
<p>Odd-Even Transposition Sort is based on the Bubble Sort technique. It compares two adjacent numbers and switches them, if the first number is greater than the second number to get an ascending order list. The opposite case applies for a descending order series. Odd-Even transposition sort operates in two phases &minus; <b>odd phase</b> and <b>even phase</b>. In both the phases, processes exchange numbers with their adjacent number in the right.</p>
<img src="/parallel_algorithm/images/odd_even_transposition_sort.jpg" alt="Odd-Even Transposition Sort" />
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
procedure ODD-EVEN_PAR (n) 

begin 
   id := process's label 
	
   for i := 1 to n do 
   begin 
	
      if i is odd and id is odd then 
         compare-exchange_min(id + 1); 
      else 
         compare-exchange_max(id - 1);
			
      if i is even and id is even then 
         compare-exchange_min(id + 1); 
      else 
         compare-exchange_max(id - 1);
			
   end for
	
end ODD-EVEN_PAR
</pre>
<h2>Parallel Merge Sort</h2>
<p>Merge sort first divides the unsorted list into smallest possible sub-lists, compares it with the adjacent list, and merges it in a sorted order. It implements parallelism very nicely by following the divide and conquer algorithm.</p>
<img src="/parallel_algorithm/images/parallel_merge_sort.jpg" alt="Parallel Merge Sort" />
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
procedureparallelmergesort(id, n, data, newdata)

begin
   data = sequentialmergesort(data)
	
      for dim = 1 to n
         data = parallelmerge(id, dim, data)
      endfor
		
   newdata = data
end
</pre>
<h2>Hyper Quick Sort</h2>
<p>Hyper quick sort is an implementation of quick sort on hypercube. Its steps are as follows &minus;</p>
<ul class="list">
<li>Divide the unsorted list among each node.</li>
<li>Sort each node locally.</li>
<li>From node 0, broadcast the median value.</li>
<li>Split each list locally, then exchange the halves across the highest dimension.</li>
<li>Repeat steps 3 and 4 in parallel until the dimension reaches 0.</li>
</ul>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
procedure HYPERQUICKSORT (B, n)
begin

   id := process’s label;
	
   for i := 1 to d do
      begin
      x := pivot;
      partition B into B1 and B2 such that B1 &le; x &lt; B2;
      if ith bit is 0 then
		
      begin
         send B2 to the process along the ith communication link;
         C := subsequence received along the ith communication link;
         B := B1 U C;
      endif
      
      else
         send B1 to the process along the ith communication link;
         C := subsequence received along the ith communication link;
         B := B2 U C;
         end else
      end for
		
   sort B using sequential quicksort;
	
end HYPERQUICKSORT
</pre>
<h1>Parallel Search Algorithm</h1>
<p>Searching is one of the fundamental operations in computer science. It is used in all applications where we need to find if an element is in the given list or not. In this chapter, we will discuss the following search algorithms &minus;</p>
<ul class="list">
<li>Divide and Conquer</li>
<li>Depth-First Search</li>
<li>Breadth-First Search</li>
<li>Best-First Search</li>
</ul>
<h2>Divide and Conquer</h2>
<p>In divide and conquer approach, the problem is divided into several small sub-problems. Then the sub-problems are solved recursively and combined to get the solution of the original problem.</p>
<p>The divide and conquer approach involves the following steps at each level &minus;</p>
<ul class="list">
<li><p><b>Divide</b> &minus; The original problem is divided into sub-problems.</p></li>
<li><p><b>Conquer</b> &minus; The sub-problems are solved recursively.</p></li>
<li><p><b>Combine</b> &minus; The solutions of the sub-problems are combined to get the solution of the original problem.</p></li>
</ul>
<p>Binary search is an example of divide and conquer algorithm.</p>
<h3>Pseudocode</h3>
<pre class="prettyprint notranslate">
Binarysearch(a, b, low, high)

if low &lt; high then
   return NOT FOUND
else
   mid &larr; (low+high) / 2
   if b = key(mid) then
      return key(mid)
   else if b &lt; key(mid) then
      return BinarySearch(a, b, low, mid−1)
   else
   
      return BinarySearch(a, b, mid+1, high)
</pre>
<h2>Depth-First Search</h2>
<p>Depth-First Search (or DFS) is an algorithm for searching a tree or an undirected graph data structure. Here, the concept is to start from the starting node known as the <b>root</b> and traverse as far as possible in the same branch. If we get a node with no successor node, we return and continue with the vertex, which is yet to be visited.</p>
<h3>Steps of Depth-First Search</h3>
<ul class="list">
<li><p>Consider a node (root) that is not visited previously and mark it visited.</p></li>
<li><p>Visit the first adjacent successor node and mark it visited.</p></li>
<li><p>If all the successors nodes of the considered node are already visited or it doesn’t have any more successor node, return to its parent node.</p></li>
</ul>
<h3>Pseudocode</h3>
<p>Let <b>v</b> be the vertex where the search starts in Graph <b>G</b>.</p>
<pre class="prettyprint notranslate">
DFS(G,v)

   Stack S := {};
	
   for each vertex u, set visited[u] := false;
   push S, v;
   while (S is not empty) do
     u := pop S;
	  
      if (not visited[u]) then
         visited[u] := true;
         for each unvisited neighbour w of u
            push S, w;
      end if
		
   end while
   
END DFS()
</pre>
<h2>Breadth-First Search</h2>
<p>Breadth-First Search (or BFS) is an algorithm for searching a tree or an undirected graph data structure. Here, we start with a node and then visit all the adjacent nodes in the same level and then move to the adjacent successor node in the next level. This is also known as <b>level-by-level search</b>.</p>
<h3>Steps of Breadth-First Search</h3>
<ul class="list">
<li>Start with the root node, mark it visited.</li>
<li>As the root node has no node in the same level, go to the next level.</li>
<li>Visit all adjacent nodes and mark them visited.</li>
<li>Go to the next level and visit all the unvisited adjacent nodes.</li>
<li>Continue this process until all the nodes are visited.</li>
</ul>
<h3>Pseudocode</h3>
<p>Let <b>v</b> be the vertex where the search starts in Graph <b>G</b>.</p>
<pre class="prettyprint notranslate">
BFS(G,v)

   Queue Q := {};
	
   for each vertex u, set visited[u] := false;
   insert Q, v;
   while (Q is not empty) do
      u := delete Q;
		
      if (not visited[u]) then
         visited[u] := true;
         for each unvisited neighbor w of u
            insert Q, w;
      end if
		
   end while
   
END BFS()
</pre>
<h2>Best-First Search</h2>
<p>Best-First Search is an algorithm that traverses a graph to reach a target in the shortest possible path. Unlike BFS and DFS, Best-First Search follows an evaluation function to determine which node is the most appropriate to traverse next.</p>
<h3>Steps of Best-First Search</h3>
<ul class="list">
<li>Start with the root node, mark it visited.</li>
<li>Find the next appropriate node and mark it visited.</li>
<li>Go to the next level and find the appropriate node and mark it visited.</li>
<li>Continue this process until the target is reached.</li>
</ul>
<h3>Pseudocode</h3>
<pre class="prettyprint notranslate">
BFS( m )

   Insert( m.StartNode )
   Until PriorityQueue is empty
      c &larr; PriorityQueue.DeleteMin
      If c is the goal
      Exit
   Else
   
      Foreach neighbor n of c
         If n "Unvisited"
            Mark n "Visited"
            Insert( n )
      Mark c "Examined"
      
End procedure
</pre>
<h1>Graph Algorithm</h1>
<p>A graph is an abstract notation used to represent the connection between pairs of objects. A graph consists of &minus;</p>
<ul class="list">
<li><p><b>Vertices</b> &minus; Interconnected objects in a graph are called vertices. Vertices are also known as <b>nodes</b>.</p></li>
<li><p><b>Edges</b> &minus; Edges are the links that connect the vertices.</p></li>
</ul>
<p>There are two types of graphs &minus;</p>
<ul class="list">
<li><p><b>Directed graph</b> &minus; In a directed graph, edges have direction, i.e., edges go from one vertex to another.</p></li>
<li><p><b>Undirected graph</b> &minus; In an undirected graph, edges have no direction.</p></li>
</ul>
<h2>Graph Coloring</h2>
<p>Graph coloring is a method to assign colors to the vertices of a graph so that no two adjacent vertices have the same color. Some graph coloring problems are &minus;</p>
<ul class="list">
<li><p><b>Vertex coloring</b> &minus; A way of coloring the vertices of a graph so that no two adjacent vertices share the same color.</p></li>
<li><p><b>Edge Coloring</b> &minus; It is the method of assigning a color to each edge so that no two adjacent edges have the same color.</p></li>
<li><p><b>Face coloring</b> &minus; It assigns a color to each face or region of a planar graph so that no two faces that share a common boundary have the same color.</p></li>
</ul>
<h3>Chromatic Number</h3>
<p>Chromatic number is the minimum number of colors required to color a graph. For example, the chromatic number of the following graph is 3.</p>
<img src="/parallel_algorithm/images/graph.jpg" alt="Graph" />
<p>The concept of graph coloring is applied in preparing timetables, mobile radio frequency assignment, Suduku, register allocation, and coloring of maps.</p>
<h3>Steps for graph coloring</h3>
<ul class="list">
<li><p>Set the initial value of each processor in the n-dimensional array to 1.</p></li>
<li><p>Now to assign a particular color to a vertex, determine whether that color is already assigned to the adjacent vertices or not.</p></li>
<li><p>If a processor detects same color in the adjacent vertices, it sets its value in the array to 0.</p></li>
<li><p>After making n<sup>2</sup> comparisons, if any element of the array is 1, then it is a valid coloring.</p></li>
</ul>
<h3>Pseudocode for graph coloring</h3>
<pre class="prettyprint notranslate">
begin

   create the processors P(i<sub>0</sub>,i<sub>1</sub>,...i<sub>n-1</sub>) where 0_i<sub>v</sub> &lt; m, 0 _ v &lt; n
   status[i0,..i<sub>n-1</sub>] = 1
	
   for j varies from 0 to n-1 do
      begin
		
         for k varies from 0 to n-1 do
         begin
            if a<sub>j,k</sub>=1 and i<sub>j</sub>=i<sub>k</sub>then
            status[i<sub>0</sub>,..i<sub>n-1</sub>] =0
         end
			
      end
      ok = &Sigma;Status
		
   if ok &gt; 0, then display valid coloring exists
   else
      display invalid coloring
      
end
</pre>
<h2>Minimal Spanning Tree</h2>
<p>A spanning tree whose sum of weight (or length) of all its edges is less than all other possible spanning tree of graph G is known as a <b>minimal spanning tree</b> or <b>minimum cost spanning</b> tree. The following figure shows a weighted connected graph.</p>
<img src="/parallel_algorithm/images/minimal_spanning_tree.jpg" alt="Minimal Spanning Tree" />
<p>Some possible spanning trees of the above graph are shown below &minus;</p>
<img src="/parallel_algorithm/images/spanning_tree.jpg" alt="Spanning Tree" />
<img src="/parallel_algorithm/images/spanning_tree1.jpg" alt="Spanning Tree 1" />
<img src="/parallel_algorithm/images/spanning_tree2.jpg" alt="Spanning Tree 2" />
<img src="/parallel_algorithm/images/minimum_spanning_tree.jpg" alt="Minimum Spanning Tree" />
<img src="/parallel_algorithm/images/spanning_tree3.jpg" alt="Spanning Tree 3" />
<img src="/parallel_algorithm/images/spanning_tree4.jpg" alt="Spanning Tree 4" />
<img src="/parallel_algorithm/images/spanning_tree5.jpg" alt="Spanning Tree 5" />
<p>Among all the above spanning trees, figure (d) is the minimum spanning tree. The concept of minimum cost spanning tree is applied in travelling salesman problem, designing electronic circuits, Designing efficient networks, and designing efficient routing algorithms.</p>
<p>To implement the minimum cost-spanning tree, the following two methods are used &minus;</p>
<ul class="list">
<li>Prim’s Algorithm</li>
<li>Kruskal’s Algorithm</li>
</ul>
<h2>Prim's Algorithm</h2>
<p>Prim’s algorithm is a greedy algorithm, which helps us find the minimum spanning tree for a weighted undirected graph. It selects a vertex first and finds an edge with the lowest weight incident on that vertex.</p>
<h3>Steps of Prim’s Algorithm</h3>
<ul class="list">
<li><p>Select any vertex, say v<sub>1</sub> of Graph G.</p></li>
<li><p>Select an edge, say e<sub>1</sub> of G such that e<sub>1</sub> = v<sub>1</sub> v<sub>2</sub> and v<sub>1</sub> &ne; v<sub>2</sub> and e<sub>1</sub> has minimum weight among the edges incident on v<sub>1</sub> in graph G.</p></li>
<li><p>Now, following step 2, select the minimum weighted edge incident on v<sub>2</sub>.</p></li>
<li><p>Continue this till n–1 edges have been chosen. Here <b>n</b> is the number of vertices.</p></li>
</ul>
<img src="/parallel_algorithm/images/graph_prims_algorithm.jpg" alt="Graph Prim’s Algorithm" />
<p>The minimum spanning tree is &minus;</p>
<img src="/parallel_algorithm/images/prims_algorithm_minimum_spanning_tree.jpg" alt="Prim’s Algorithm Minimum Spanning Tree" />
<h2>Kruskal's Algorithm</h2>
<p>Kruskal’s algorithm is a greedy algorithm, which helps us find the minimum spanning tree for a connected weighted graph, adding increasing cost arcs at each step. It is a minimum-spanning-tree algorithm that finds an edge of the least possible weight that connects any two trees in the forest.</p>
<h3>Steps of Kruskal’s Algorithm</h3>
<ul class="list">
<li><p>Select an edge of minimum weight; say e<sub>1</sub> of Graph G and e<sub>1</sub> is not a loop.</p></li>
<li><p>Select the next minimum weighted edge connected to e<sub>1</sub>.</p></li>
<li><p>Continue this till n–1 edges have been chosen. Here <b>n</b> is the number of vertices.</p></li>
</ul>
<img src="/parallel_algorithm/images/kruskals_algorithm_graph.jpg" alt="Kruskal’s Algorithm Graph" />
<p>The minimum spanning tree of the above graph is &minus;</p>
<img src="/parallel_algorithm/images/minimum_spanning_tree_kruskals_algorithm.jpg" alt="Minimum Spanning Tree of Kruskal’s Algorithm" />
<h2>Shortest Path Algorithm</h2>
<p>Shortest Path algorithm is a method of finding the least cost path from the source node(S) to the destination node (D). Here, we will discuss Moore’s algorithm, also known as Breadth First Search Algorithm.</p>
<h3>Moore’s algorithm</h3>
<ul class="list">
<li><p>Label the source vertex, S and label it <b>i</b> and set <b>i=0</b>.</p></li>
<li><p>Find all unlabeled vertices adjacent to the vertex labeled <b>i</b>. If no vertices are connected to the vertex, S, then vertex, D, is not connected to S. If there are vertices connected to S, label them <b>i+1</b>.</p></li>
<li><p>If D is labeled, then go to step 4, else go to step 2 to increase i=i+1.</p></li>
<li><p>Stop after the length of the shortest path is found.</p></li>
</ul>
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/parallel_algorithm/graph_algorithm.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/parallel_algorithm/parallel_algorithm_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
